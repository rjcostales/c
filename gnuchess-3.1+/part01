From pa.dec.com!decwrl!uunet!sparky!kent Sun May 19 12:33:55 PDT 1991
Article: 2353 of comp.sources.misc
Newsgroups: comp.sources.misc
Path: pa.dec.com!decwrl!uunet!sparky!kent
From: Mike McGann <mwm@hasler.ascom.ch>
Subject:  v19i073:  gnuchess - gnuchess version 3.1+, Part01/07
Message-ID: <1991May17.024417.27553@sparky.IMD.Sterling.COM>
X-Md4-Signature: a3de8b65efff93d6077bbe0ab19c6987
Sender: kent@sparky.IMD.Sterling.COM (Kent Landfield)
Organization: Sterling Software, IMD
Date: Fri, 17 May 1991 02:44:17 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Mike McGann <mwm@hasler.ascom.ch>
Posting-number: Volume 19, Issue 73
Archive-name: gnuchess/part01

This is an update of gnuchess version 3.1.  It fixes all known bugs with 
pawn promotion, undo, and win/draw determination.  It adds the capability 
of reading xboard position files (xget).  It adds specification of save 
and load files on the command line (gnuchessr).  Save file format is now 
human readable.  'white' and 'black' no longer start play but only set the 
players. If the computer is to move first use the 'go' command.

New commands are xget and hashlevel.
	xget reads an xboard position file.
	hashlevel allows you to specify parameters for using the hashfile.

New Programs -
	postprint - allows printing of hashfile contents on a postscript printer
		for each position it prints tha board and the recommended move
		flags and depth.
		To run: just execute the program (pathname for hashfile is
			build in. Output comes out stdout. Then cat it with 
			ChessFonts and sent it to the printer. It prints 16
			positions per page.

			postprint >t
			cat ChessFonts t >p
			lpr p

	gnuan - a modified version of Truman Collins gnuan program with fixes
                for the gnuchess bugs. In addition it shows the best line for
                each move instead of just the next move. It will accept input
	        files produced by xboard (xboard.game.save) or from gnuchess
	        (chess.lst) files directly. 
		
		Output looks like this:

    Move White Black      Score Depth     Best Line
    ------------------------------------------------------------------
      1   e2e4              13    5    g1f3  g8f6  b1c3  b8c6  e2e3 
                c7c5        -2    5    e7e6  b1c3  b8c6  d2d4  f8b4 
      2   b1c3              37    5    b1c3  b8c6  g1f3  g8f6  f1c4 
                b8c6       -34    5    b8c6  g1f3  g8f6  f1b5  c6b4 
      3   g1f3              44    5    g1f3  g8f6  f1b5  h7h6  d2d3 
                g8f6       -38    5    g8f6  f1b5  a7a6  b5c6  d7c6 
      4   f1c4              38    5    f1b5  c6d4  d2d3  d4b5  c3b5 
                d7d6       -20    5    d7d6  d2d3  c8g4  h2h3  g4h5 
    
            White's percentage was 50.00%.     Black's percentage was 75.00%.
    
            Elapsed time was 128 seconds.

Mike McGann <uunet!hasler.ascom.ch!mwm>
----
#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/24/1991 20:35 UTC by kent@sparky.IMD.Sterling.COM
# Source directory /u1/csm/queue/gnuchess/test
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   6143 -rw-rw-r-- ChangeLog
#  28062 -rw-rw-r-- ChessFont
#   6506 -rw-rw-r-- MAN-PAGE
#   3665 -rw-rw-r-- Makefile
#   3150 -rw-rw-r-- Makefile.dos
#   2119 -rw-rw-r-- README
#  21324 -rw-rw-r-- gnuan.c
#    743 -rw-rw-r-- gnuan.hlp
#  47344 -r--r--r-- gnuchess.book
#  79899 -rw-rw-r-- gnuchess.c
#   7534 -rw-rw-r-- gnuchess.h
#  30778 -rw-rw-r-- nondsp.c
#  38643 -rw-rw-r-- nuxdsp.c
#   4447 -rw-rw-r-- postprint.c
#  34750 -rw-rw-r-- uxdsp.c
#    234 -rw-rw-r-- version.h
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= ChangeLog ==============
if test -f 'ChangeLog' -a X"$1" != X"-c"; then
	echo 'x - skipping ChangeLog (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ChangeLog (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ChangeLog' &&
Mon Apr 15 10:20 1991 Mike McGann {mwm@hslrswi.hasler.ascom.ch)
X	Fix Undo's incorrect handling of promotions.
X	Fix win and draw determination bugs.
X 	Fix bug in algbr that prevented correct display of promotion moves.
X	Fix Undo to correctly display side to move.
X	Add path to command line for save file and load file.
X	Make save file human readable
X	
Thu May 24 13:42:24 1990  Hans Eric Sandstr|m  (hes at baloo)
X	* Fixed a bug reported by Brian Wong (wong@cs.UAlberta.CA) in
X	ScoreKPK
X
Sat May  5 15:58:31 1990  Hans Eric Sandstr|m  (hes at baloo)
X	* extensive tests on MSDOS for 2 weeks and lots of changes:
X	Moved all flags to a special flag structure.
X	Added my own TODO file to the DOCUMENTATION.
X	Moved GetOpenings and parse from the *dsp.c files.
X	Made the transposition table enabled by default.
X	Some cleanup in the *dsp.c code.
X	Changed UpdateHashbd to a macro.
X
Wed Apr 18 16:38:30 1990  Hans-Erik Sandstr|m  (hes at tiamat)
X	* Removed unnessesary global variables:
X	(wking, bking, Enemyking, INCscore, slk, InChk, HasPawn,
X	Zwmtl, Zbmtl, lpost, KBNKsq) this should make the program more
X	readable.
X	* Added a mini transposition table to detect repetitions, this
X	means that repetition is called more seldom and should save some
X	time. The idea for this came from Benno Tietz
X	(tietz@eos.informatik.uni-bonn.de)
X
Thu Mar 29 02:49:00 1990  Thorsten Ohl at (td12@ddagsi3.bitnet)
X     * nuxdsp.c has been given an ANSI interface (tailored
X	after uxdsp.c as of Version 3.00 and a homegrown
X	ANSI interface created in January for Version 1.55).
X     *	uxdsp.c now understands ^C interrupts.
X     *	both nuxdsp.c and uxdsp.c support the graphic characters
X	of the IBM PC (can be disabled with -DSEVENBIT).
X	It's of course a matter of taste, but I think it looks
X	much better.
X     * I have added prototypes and a makefile for a **IX compatible
X	MS-DOS make (neither Turbo C or Microsoft C will understand
X	this!).
X     *	some formal parameters are not referenced. This is due to the
X	different display interfaces and no problem at all. Just for
X	aesthetic reasons I have shut up the compiler by incrementing
X	the unreferenced variables.
X     *	some longs are assigned to shorts and some shorts to unsigned chars.
X	I have introduced a cast in each case, all are o.k. (as far
X	as I can tell).
X
Thu Mar  8 09:11:28 1990  Hans-Erik Sandstr|m  (hes at orsa1)
X	* The persistent hash table seems to work now. There are still some
X	problems using it on a heterogenous network.
X
Sun Mar  4 14:44:44 1990  Hans Eric Sandstr|m  (hes at orsa)
X	* I am working on a persistent hash table. Currenly a 10Mb file
X	with 262144 entrys. Stuart just asked me to spilt the posdata
X	array to make gnuchess work better on a PC, so I did that.
X	I have also tried to properly fix the bug that caused gnuchess
X	to report mate prematurely. This, I hope, will also improve the
X	search.
X
Tue Feb 27 18:27:23 1990  Hans Eric Sandstr|m  (hes at davidson.log-sv.se)
X	* used protoize to make a function prototyped version of gnuchess.
X	this means that I have to use unprotoize before 'make distribution'
X	to make a more portable K&R version.
X	removed a ZeroTTable so now the hashtable is kept between moves.
X
Sat Feb 24 13:14:14 1990  Hans Eric Sandstr|m  (hes at orsa)
X	* Added a test to detect hash table collisions, define HASHTEST.
X	I also removed 	the times calls since there is no sense in
X	measuring cpu time when	wallclock time is all that counts when
X	playing chess.
X
Fri Feb 23 17:25:37 1990  Hans Eric Sandstr|m  (hes at orsa)
X	* Compiled gnuchess with gcc1.37 -Wall and got lots of
X	implicit decaration warnings. Solved most of these by adding
X	external declarations in gnuchess.h.
X
Wed Feb 21 17:41:28 1990 Jouko Holopainen (jhol@tolsun.oulu.fi) 
X	* Contributed his code for ECO move entry (again!)
X	and a file ansidsp.c (A msdos port of uxdsp.c).
X	I(hes) started a merge of ansidsp.c and uxdsp.c.
X
February 8, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Changed the transpositon table to allow 65536 positions per player.
X	This means a 1.3 Mbyte hash table. Introduced simple rehashing. And
X	also made setting ttable 0 exclude all transposition code from
X	gnuchess (for machines with very little memory).
X
X
February 3, 1990 -- Tom Vijlbrief (tnosoes!tom@nluug.n)
X	Contributed code to fix undo of promotions.
X	And a bugfix RMBLTY was to small.
X
X
Januari 27, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Fixed nuxdsp.c to work with my changes (Saved games format)
X
X
Januari 26, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Verified that the underpromotion routines works.
X	Found and fixed the bug that caused gnuchess to report mate
X	and draw prematurely.
X
X
Januari 25, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Received the underpromotion additions from jhol@tolsun.oulu.fi
X	Made some optimizations in trapped and KingScan.
X	Added more comments on how to improve the search.
X	Added info on usage of the array Tree in post mode.
X	Changed the index in the transposition table to unsigned short to
X	allow a hash table of size 65536.
X
X
Januari 11, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Formatted gnuchess according to GNU standards with indent.
X
X
Januari 9, 1990 -- Hans Eric Sandstrom (hes@log-sv.se)
X	Inserted a missing comma in KTHRT.
X	Removed mvstr1[5],mvstr2[5] from gnuchess.c, they are only used in the
X	user-interface routines uxdsp.c nondsp.c anyway.
X	Rewrote algbr to generate move strings for underpromotion.
X	(ph8k or h7h8k)
X	Some optimizations in CaptureList.
X	Changed row, column and locn to macros.
X	Made memset default and introduced a switch NOMEMSET for
X	computers without memset or where memset is a speed penality.
X	I tested this on:
X		Sparc		- no change
X		DECstation	- no change
X		Sun3/60		- 4% speed improvment.
X	Changed + to | in some bit-field manipulations.
X	Fixed the castle-with-moved-rook-bug, removed kingmoved and introduced
X	an array Mvboard to keep track on how many times we have moved from a
X	particular square.
X	Fixed the check for zero division in Time controls.
X	Added BINDIR and LIBDIR in the Makefile to set where gnuchess and
X	gnuchess.book gets installed.
X	All I have to do now is to test if all this works (-:
SHAR_EOF
chmod 0664 ChangeLog ||
echo 'restore of ChangeLog failed'
Wc_c="`wc -c < 'ChangeLog'`"
test 6143 -eq "$Wc_c" ||
	echo 'ChangeLog: original size 6143, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ChessFont ==============
if test -f 'ChessFont' -a X"$1" != X"-c"; then
	echo 'x - skipping ChessFont (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ChessFont (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ChessFont' &&
%!PS-Adobe-1.0
%% This is my font for chess and similar pieces.  It is supplied "as is".
%% It works for me, I have no idea whether it will work for you;  you gets
%% what you pays for.  Before using it, you should read the Copyright
%% notice below and the "README" file which should accompany this file.
%%    -- ANW, March 1991.
X
/Cfont 9 dict dup begin
X
/FontMatrix [ 0.001 0 0 0.001 0 0 ] readonly def
/FontType 3 def
/FontBBox [ 0 0 0 0 ] readonly def
/Encoding 256 array def
/FontInfo 3 dict dup begin
X  /Notice (
X
X	Copyright (c) 1991 A. N. Walker.  All rights reserved.
X
X	This notice must be preserved in all versions of this file, and
X	any alterations which you make must be clearly marked as such.
X	For further information, see the "README" file which should
X	accompany this, or contact me at Dept of Mathematics, Nottingham
X	Univ., UK, anw@maths.nott.ac.uk.
X
X     ) readonly def
X  /FullName (ChessFont) readonly def
X  /version (2.0) readonly def
end def
/UniqueID 472474 def
X
Encoding
0 1 255 { 2 copy /.notdef put pop } for
dup 8#040 /Wsquare put		% ' '
dup 8#042 /flap put		% '"'
dup 8#043 /board put		% '#'
dup 8#047 /flip put		% ''''
dup 8#052 /Bsquare put		% '*'
dup 8#055 /edge put		% '-'
dup 8#056 /blobfig put		% '.'
dup 8#057 /corner put		% '/'
dup 8#060 /m0 put		% '0'
dup 8#061 /Wsquare put		% '1'
dup 8#062 /m2 put		% '2'
dup 8#063 /m3 put		% '3'
dup 8#064 /m4 put		% '4'
dup 8#065 /m5 put		% '5'
dup 8#066 /m6 put		% '6'
dup 8#067 /m7 put		% '7'
dup 8#070 /m8 put		% '8'
dup 8#071 /m9 put		% '9'
dup 8#073 /nextline put		% ';'
dup 8#074 /m-1 put		% '<'
dup 8#076 /Wsquare put		% '>'
dup 8#100 /wblock put		% '@'
dup 8#102 /WB put		% 'B'
dup 8#103 /WC put		% 'C'
dup 8#104 /WD put		% 'D'
dup 8#105 /WE put		% 'E'
dup 8#106 /WF put		% 'F'
dup 8#107 /WG put		% 'G'
dup 8#111 /blob put		% 'I'
dup 8#113 /WK put		% 'K'
dup 8#114 /WL put		% 'L'
dup 8#115 /WM put		% 'M'
dup 8#116 /WN put		% 'N'
dup 8#117 /BO put		% 'O'
dup 8#120 /WP put		% 'P'
dup 8#121 /WQ put		% 'Q'
dup 8#122 /WR put		% 'R'
dup 8#123 /WS put		% 'S'
dup 8#124 /WT put		% 'T'
dup 8#125 /WU put		% 'U'
dup 8#126 /WV put		% 'V'
dup 8#130 /WX put		% 'X'
dup 8#132 /WZ put		% 'Z'
dup 8#133 /posstart put		% '['
dup 8#135 /posfinish put	% ']'
dup 8#137 /underbar put		% '_'
dup 8#142 /BB put		% 'b'
dup 8#143 /BC put		% 'c'
dup 8#144 /BD put		% 'd'
dup 8#145 /BE put		% 'e'
dup 8#146 /BF put		% 'f'
dup 8#147 /BG put		% 'g'
dup 8#151 /blob put		% 'i'
dup 8#153 /BK put		% 'k'
dup 8#154 /BL put		% 'l'
dup 8#155 /BM put		% 'm'
dup 8#156 /BN put		% 'n'
dup 8#157 /BO put		% 'o'
dup 8#160 /BP put		% 'p'
dup 8#161 /BQ put		% 'q'
dup 8#162 /BR put		% 'r'
dup 8#163 /BS put		% 's'
dup 8#164 /BT put		% 't'
dup 8#165 /BU put		% 'u'
dup 8#166 /BV put		% 'v'
dup 8#170 /BX put		% 'x'
dup 8#172 /BZ put		% 'z'
dup 8#174 /sidebar put		% '|'
dup 8#240 /Wsquare put		% ' '+
dup 8#241 /without put		% '!'+
dup 8#242 /flap put		% '"'+
dup 8#243 /board put		% '#'+
dup 8#245 /infinityequals put	% '%'+
dup 8#247 /flip put		% ''''+
dup 8#252 /circledot put	% '*'+
dup 8#253 /plus put		% '+'+
dup 8#255 /minus put		% '-'+
dup 8#272 /doubled put		% ':'+
dup 8#273 /nextline put		% ';'+
dup 8#274 /equalsplus put	% '<'+
dup 8#275 /equal put		% '='+
dup 8#276 /plusequals put	% '>'+
dup 8#277 /infinity put		% '?'+
dup 8#300 /circarrow put	% '@'+
dup 8#302 /Bfig put		% 'B'+
dup 8#303 /Cfig put		% 'C'+
dup 8#304 /Dfig put		% 'D'+
dup 8#305 /Efig put		% 'E'+
dup 8#306 /Ffig put		% 'F'+
dup 8#307 /Gfig put		% 'G'+
dup 8#311 /blobfig put		% 'I'+
dup 8#313 /Kfig put		% 'K'+
dup 8#314 /Lfig put		% 'L'+
dup 8#315 /Mfig put		% 'M'+
dup 8#316 /Nfig put		% 'N'+
dup 8#317 /Ofig put		% 'O'+
dup 8#320 /Pfig put		% 'P'+
dup 8#321 /Qfig put		% 'Q'+
dup 8#322 /Rfig put		% 'R'+
dup 8#323 /Sfig put		% 'S'+
dup 8#324 /Tfig put		% 'T'+
dup 8#325 /Ufig put		% 'U'+
dup 8#326 /Vfig put		% 'V'+
dup 8#330 /Xfig put		% 'X'+
dup 8#332 /Zfig put		% 'Z'+
dup 8#333 /minusorplus put	% '['+
dup 8#335 /plusorminus put	% ']'+
dup 8#336 /uparrow put		% '^'+
dup 8#341 /rightarrow put	% 'a'+
dup 8#342 /semicircle put	% 'b'+
dup 8#343 /centre put		% 'c'+
dup 8#344 /diags put		% 'd'+
dup 8#345 /etc put		% 'e'+
dup 8#346 /Phalo put		% 'f'+
dup 8#347 /samebs put		% 'g'+
dup 8#350 /edgefig put		% 'h'+
dup 8#351 /triangle put		% 'i'+
dup 8#352 /Bsquarefig put	% 'j'+
dup 8#353 /kside put		% 'k'+
dup 8#354 /line put		% 'l'+
dup 8#355 /hash put		% 'm'+
dup 8#356 /cornerfig put	% 'n'+
dup 8#357 /square put		% 'o'+
dup 8#360 /ending put		% 'p'+
dup 8#361 /qside put		% 'q'+
dup 8#362 /Pfill put		% 'r'+
dup 8#363 /separated put	% 's'+
dup 8#364 /tempo put		% 't'+
dup 8#365 /united put		% 'u'+
dup 8#366 /oppbs put		% 'v'+
dup 8#367 /with put		% 'w'+
dup 8#370 /weakpt put		% 'x'+
dup 8#371 /bpair put		% 'y'+
dup 8#372 /circlebolddot put	% 'z'+
X    8#374 /botharrow put	% '|'+
X
/CharProcs 200 dict dup begin
X
% Miscellaneous:
X	/.notdef { } bind def
X	/Arcto  { arcto 4 { pop } repeat } bind def
X	/Ddn3c  { dup dup neg 3 copy } bind def
X	/Round  { dtransform round exch round exch idtransform } bind def
X	/Rlineto { Round rlineto } bind def
X	/Rmoveto { Round rmoveto } bind def
X	/diamond { moveto dup neg 0 rmoveto dup dup neg rlineto
X		dup dup rlineto dup neg exch rlineto closepath } bind def
X	/dohalo { gsave 100 setlinewidth setW stroke grestore } bind def
X	/dofill { gsave fill grestore } bind def
X	/motion { 1000 mul exch 1000 mul exch setcharwidth } bind def
X	/setW	{ 1 setgray } bind def
X	/setB	{ 0 setgray } bind def
X	/drawingB { 0 currentgray eq } bind def
X	/setfig { 1000 0 0 -200 1000 800 setcachedevice 500 300 translate
X		} bind def
X	/setpce { 1000 0 setcharwidth 500 dup translate 0.95 dup scale
X		} bind def
X	/MiscStr (a) def
X	/tofig  { 0 get 8#200 add MiscStr exch 0 exch put MiscStr } bind def
X	/Tofig  { 1 0.95 div dup scale tofig } bind def
X	/intext true def
X	/flip	{ 0 0 setcharwidth /intext intext not def } bind def
X	/flap	{ 0 0 setcharwidth /intext true def } bind def
X	/Setfont { /ChessFont findfont 1000 scalefont setfont } bind def
X	/Show	{ rotate -500 dup moveto Setfont show } bind def
X	/Showfig { rotate -500 -300 moveto Setfont show } bind def
X	/LocStr (a) def
X	/SetChar {
X		dup 8#047 eq { pop flip stop } if
X		dup 8#200 lt { intext {
X			8#200 add LocStr exch 0 exch put
X			Setfont LocStr dup stringwidth setcharwidth
X			0 0 moveto show stop } if } if } bind def
X	/DoChar { Encoding exch get cvx exec } bind def
X
% Kings
X	/WK {	setpce Kout dohalo setW dofill setB stroke Kin } bind def
X	/BK {	setpce Kout dohalo dofill stroke setW Kin } bind def
X	/Kfig { setfig Kout stroke Kin } bind def
X
X	/Kout {	2 setmiterlimit
X		325 -100 moveto 600 100 350 400 125 250 curveto
X		0 250 rlineto -250 0 rlineto 0 -250 rlineto
X		-350 400 -600 100 -325 -100 curveto 0 -250 rlineto
X		-100 -500 100 -500 325 -350 curveto closepath
X		30 setlinewidth } bind def
X	/Kin {	drawingB { 325 } { 275 } ifelse
X		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto
X		-350 lineto -100 moveto 0 -50 3 -1 roll
X		-100 800 Arcto -100 lineto
X		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
X		drawingB { 125 } { 75 } ifelse
X		Ddn3c dup dup 4 { 0 375 moveto rlineto } repeat
X		drawingB { 0 -45 moveto 125 250 lineto -250 0 rlineto
X			closepath } { 15 0 180 diamond 265 -95 moveto
X			480 150 280 380 50 -50 curveto -265 -95 moveto
X			-480 150 -280 380 -50 -50 curveto } ifelse
X		stroke } bind def
X
% Queens
X	/WQ {	setpce Qout dohalo setW dofill setB stroke Qin } bind def
X	/BQ {	setpce Qout dohalo dofill stroke setW Qin } bind def
X	/Qfig { setfig Qout stroke Qin } bind def
X
X	/Qout {	2 setmiterlimit
X		0 75 moveto -150 440 50 -80 280 arc -250 25 lineto
X		-440 200 50 -60 300 arc -325 -100 lineto 0 -250 rlineto
X		-100 -500 100 -500 325 -350 curveto 0 250 rlineto
X		440 200 50 -120 240 arc 250 25 lineto 150 440 50 -100 260 arc
X		closepath 30 setlinewidth } bind def
X	/Qin {	drawingB { 325 } { 275 } ifelse
X		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto -350 lineto
X		-100 moveto 0 -50 3 -1 roll -100 800 Arcto -100 lineto
X		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
X		stroke } bind def
X
% Rooks
X	/WR {	setpce Rout dohalo setW dofill setB stroke Rin } bind def
X	/BR {	setpce Rout dohalo dofill stroke setW Rin } bind def
X	/Rfig { setfig Rout stroke Rin } bind def
X
X	/Rout { -325 -450 moveto 650 0 rlineto 0 50 rlineto -100 175 rlineto
X		0 400 rlineto 50 75 rlineto 0 150 rlineto -86 0 rlineto
X		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
X		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
X		0 -150 rlineto 50 -75 rlineto 0 -400 rlineto -100 -175 rlineto
X		closepath 30 setlinewidth } bind def
X	/Rin {	drawingB { -225 } { -195 } ifelse
X		dup -225 moveto dup -2 mul 0 rlineto
X		dup 175 moveto -2 mul 0 rlineto stroke } bind def
X
% Bishops
X	/WB {	Bsetpce Bout setW dofill setB stroke Bin } bind def
X	/BB {	Bsetpce Bout dofill stroke setW Bin } bind def
X	/Bfig { Bsetfig Bout stroke Bin } bind def
X
X	/Bsetpce { /Binpce true def setpce } bind def
X	/Bsetfig { /Binpce false def setfig } bind def
X	/Bout {	2 setmiterlimit
X		-400 -500 moveto 100 100 300 0 400 100 rcurveto
X		100 -100 300 0 400 -100 rcurveto 0 100 rlineto
X		-100 100 -300 0 -400 100 rcurveto
X		-100 -100 -300 0 -400 -100 rcurveto closepath
X		200 -350 moveto 0 200 rlineto
X		200 0 150 215 0 325 curveto -75 420 40 -90 270 arc
X		-340 100 -340 100 -200 -150 curveto 0 -200 rlineto
X		200 50 rlineto closepath 30 setlinewidth
X		gsave	0 325 moveto 150 215 200 0 200 -150 curveto
X			340 100 340 100 75 380 curveto 75 420 40 -90 270 arc
X			closepath Binpce { dohalo setW dofill setB } if stroke
X		grestore } bind def
X	/Bin {  15 0 -225 diamond
X		drawingB { 200 } { 150 } ifelse Ddn3c
X		-350 moveto 20 rlineto -20 rlineto -150 moveto
X		30 rlineto -30 rlineto stroke } bind def
X
% Knights
X	/WN {	setpce Nout dohalo setW dofill setB stroke Nin } bind def
X	/BN {	setpce Nout dohalo dofill stroke setW Nin } bind def
X	/Nfig { setfig Nout stroke Nin } bind def
X
X	/Nout {	2 setmiterlimit
X		450 -450 moveto 450 200 150 350 -50 400 curveto
X		-25 100 rlineto -75 -200 rlineto -75 150 rlineto
X		0 -150 rlineto -125 -125 -325 -400 -275 -450 rcurveto
X		75 -75 rlineto 100 130 rlineto 0 -200 rlineto
X		50 -25 150 100 100 150 rcurveto 50 -50 150 75 125 150 rcurveto
X		125 -300 -250 -250 -250 -450 curveto
X		closepath 30 setlinewidth } bind def
X	/Nin {  15 -200 150 diamond stroke
X		drawingB {
X			[ 100 100 ] 0 setdash 410 -450 moveto
X			410 200 130 330 -60 380 curveto 50 setlinewidth
X			stroke } {
X			430 -430 moveto 430 200 150 350 -30 370 curveto
X			150 250 390 200 390 -430 curveto fill }
X		ifelse } bind def
X
% Pawns
X	% Pawns are the only symbols which occur "frequently" in a chess
X	% diagram, so we make a special effort to optimise their caching
X	% behaviour.  Also, they are the only symbols for which this is
X	% easy!
X
X	/WP { setpce Setfont setW 0 0 moveto (f) tofig show setB (P) Tofig
X		-500 -300 rmoveto show } bind def
X	/BP { setpce Setfont setW 0 0 moveto (f) tofig show setB (r) tofig
X		show } bind def
X	/Pfig { setfig Pout stroke Pin } bind def
X
X	/Pout { 300 -450 moveto 200 -300  200 -300 75 -250 curveto
X		125 -50 125 -50 75 150 curveto 125 150 100 0 90 arc
X		0 300 100 -30 210 arc -125 150 100 90 180 arc
X		150 0 rlineto -125 -50 -125 -50 -75 -250 curveto
X		-200 -300 -200 -300 -300 -450 curveto
X		closepath 50 setlinewidth } bind def
X	/Pin { -75 150 moveto 150 0 rlineto stroke } bind def
X
X	/Phalo { 0 0 -350 -500 350 450 setcachedevice
X		Pout gsave 100 setlinewidth stroke grestore fill } bind def
X	/Pfill { 0 0 -325 -475 375 425 setcachedevice
X		Pout gsave stroke grestore fill } bind def
X
% Fous
X	% There seem to be several styles of Fou (French Bishop) -- I have
X	% selected the easiest to implement.  Anyone who *really* wants
X	% this piece can do some work for themselves!
X
X	/WF {	setpce Fout dohalo setW dofill setB stroke Fin } bind def
X	/BF {	setpce Fout dohalo dofill stroke setW Fin } bind def
X	/Ffig { setfig Fout stroke Fin } bind def
X
X	/Fout { 2 setlinejoin
X		-300 -400 moveto 150 300 rlineto -250 500 rlineto
X		250 -125 rlineto 150 175 rlineto 150 -175 rlineto
X		250 125 rlineto -250 -500 rlineto 150 -300 rlineto
X		closepath 30 setlinewidth } bind def
X
X	/Fin {  0 -400 150 dup mul 675 dup mul add sqrt
X		drawingB { 600 300 } { 30 sub 600 270 } ifelse
X		atan dup 180 sub neg arc
X		400 drawingB not { 15 5 sqrt mul add } if
X		dup neg 400 moveto dup dup -2 mul rlineto dup 2 mul rlineto
X		30 -100 150 diamond 30 100 150 diamond
X		0 175 moveto 0 -200 rlineto currentpoint stroke
X		75 210 330 arc stroke } bind def
X
% Miscellaneous Fairy pieces
X
X    % Grasshopper
X	/WG {	setpce (Q) 180 Show } bind def
X	/BG {	setpce (q) 180 Show } bind def
X	/Gfig { setfig (Q) tofig 180 Showfig } bind def
X
X    % Nightrider.  Real problemists use S for Knight and N for Nightrider;
X    %	    the weight of tradition forces N for Knight, hence S here.
X	/WS {	setpce (N) 180 Show } bind def
X	/BS {	setpce (n) 180 Show } bind def
X	/Sfig { setfig (N) tofig 180 Showfig } bind def
X
X    % Zebra
X	/WZ {	setpce (N) -90 Show } bind def
X	/BZ {	setpce (n) -90 Show } bind def
X	/Zfig { setfig (N) tofig -90 Showfig } bind def
X
X    % Mao.  Also Camel, but C is for Chameleon.
X	/WM {	setpce (N) 90 Show } bind def
X	/BM {	setpce (n) 90 Show } bind def
X	/Mfig { setfig (N) tofig 90 Showfig } bind def
X
X    % Vao
X	/WV {	setpce (B) 90 Show } bind def
X	/BV {	setpce (b) 90 Show } bind def
X	/Vfig { setfig (B) tofig 90 Showfig } bind def
X
X    % Equihopper
X	/WE {	setpce (Q) -90 Show } bind def
X	/BE {	setpce (q) -90 Show } bind def
X	/Efig { setfig (Q) tofig -90 Showfig } bind def
X
X    % Leo.  Also Locust, Lion, Edgehog
X	/WL {	setpce (Q) 90 Show } bind def
X	/BL {	setpce (q) 90 Show } bind def
X	/Lfig { setfig (Q) tofig 90 Showfig } bind def
X
X    % Pao.  Also Empress.  Sorry, all Uther mnemonics seemed to be used Up.
X	/WU {	setpce (R) 90 Show } bind def
X	/BU {	setpce (r) 90 Show } bind def
X	/Ufig { setfig (R) tofig 90 Showfig } bind def
X
X    % Orphan -- NB, all Orphans are black!
X	/BO {	setpce (p) 90 Show } bind def
X	/Ofig { setfig 90 rotate Pout dofill stroke } bind def
X
X    % Rose.  Gardeners will know why T is mnemonic for this.
X	/WT {	setpce Tout dohalo setW dofill setB stroke Tin } bind def
X	/BT {	setpce Tout dohalo dofill stroke setW Tin } bind def
X	/Tfig { setfig Tout stroke Tin } bind def
X
X	/Tout { 300 2 sqrt 1 sub mul
X		8 { dup 300 exch dup -90 135 arc 45 rotate } repeat
X		pop 50 setlinewidth } bind def
X	/Tin {  drawingB { 270 } { 300 } ifelse
X		8 { dup 0 0 moveto 0 lineto 45 rotate } repeat
X		pop stroke } bind def
X
X    % Chameleon
X	/WC {	setpce Cout dohalo setW dofill setB stroke } bind def
X	/BC {	setpce Cout dohalo dofill stroke } bind def
X	/Cfig { setfig Cout stroke } bind def
X
X	/Cout { 2 setmiterlimit 50 setlinewidth
X		-250 -350 moveto 500 0 rlineto -500 700 rlineto
X		500 0 rlineto closepath } bind def
X
X    % Blob [for marking squares], also for Imitator
X	/blob { setpce 0 0 250 0 360 arc dohalo dofill } bind def
X	/blobfig { setfig 0 200 250 0 360 arc dofill } bind def
X
% Draughts/Dame/Checkers pieces
X
X    % Man
X	/WD {	setpce Dout dohalo setW dofill setB stroke Din } bind def
X	/BD {	setpce Dout dohalo dofill stroke setW Din } bind def
X	/Dfig { setfig Dout stroke Din } bind def
X
X	/Dout { 1 0.5 scale 0 0 350 0 180 arc 0 -400 350 180 0 arc
X		closepath 50 setlinewidth } bind def
X	/Din {  0 0 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
X		ifelse arc stroke 20 setlinewidth 0 0 220 0 360 arc stroke
X		0 0 80 0 360 arc stroke } bind def
X
X    % King.  The mnemonic for this is unknown.
X	/WX {	setpce Xout dohalo setW dofill setB stroke Xin } bind def
X	/BX {	setpce Xout dohalo dofill stroke setW Xin } bind def
X	/Xfig { setfig Xout stroke Xin } bind def
X
X	/Xout { 1 0.5 scale 0 400 350 0 180 arc 0 -400 350 180 0 arc
X		closepath 50 setlinewidth } bind def
X	/Xin {  0 400 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
X		ifelse arc stroke 0 0 350 drawingB { 180 0 } { 210 -30 }
X		ifelse arc stroke 20 setlinewidth 0 400 220 0 360 arc stroke
X		0 400 80 0 360 arc stroke } bind def
X
% Board symbols
X
X	/Wsquare { 1 0 motion } bind def
X	/Bsquare { setpce (j) Tofig 90 Show } bind def
X	/Bsquarefig { 1000 0 0 0 1000 1000 setcachedevice
X		/xpix 62.5 dup dtransform /ypix exch def def
X		/xpabs xpix abs def /ypabs ypix abs def
X		xpabs ypabs lt {
X			ypabs ceiling dup 4 lt { pop 4 } if
X			dup ypix div xpix mul exch } {
X			xpabs ceiling dup 4 lt { pop 4 } if
X			dup xpix div ypix mul } ifelse
X		idtransform pop abs dup 3 div setlinewidth dup 2 mul 2000
X		{ dup 1000 lt { dup 0 moveto 0 exch lineto }
X			{ 1000 sub dup 1000 moveto 1000 exch lineto }
X			ifelse } for stroke } bind def
X	/board { 10000 0 800 0 9200 8400 setcachedevice
%		Setfont intext /intext dup true def 1000 8200 moveto
%		4 { (hhhhhhhhn) show currentpoint translate -90 rotate } repeat
%		-90 rotate 0 7000 moveto
%	The above was the intention, but the borders sometimes fail to match
%	up by a pixel or two.  Hence the following!  However, the borders
%	work perfectly well for special purposes.
X		Setfont intext /intext dup true def
X		20 setlinewidth 940 140 moveto 8120 0 Rlineto 0 8120 Rlineto
X		-8120 0 Rlineto closepath stroke
X		80 setlinewidth 840 40 moveto 8320 0 Rlineto 0 8320 Rlineto
X		-8320 0 Rlineto closepath stroke
X		2000 200 moveto 90 rotate
X		4 { (j j j j ; j j j j;) show } repeat exch def } bind def
X	/nextline { -8 -1 motion } bind def
X	/edge { setpce (h) Tofig 0 Show } bind def
X	/edgefig { 1000 0 0 0 1000 200 setcachedevice
X		20 setlinewidth 0 60 moveto 1000 0 rlineto stroke
X		80 setlinewidth 0 160 moveto 1000 0 rlineto stroke } bind def
X	/corner { setpce (n) Tofig 0 Show } bind def
X	/cornerfig { 0 0 0 0 200 200 setcachedevice
X		20 setlinewidth 0 60 moveto 60 0 rlineto 0 -60 rlineto stroke
X		80 setlinewidth 0 160 moveto 160 0 rlineto 0 -160 rlineto
X		stroke } bind def
X	/posstart { -9 7.2 motion } bind def
X	/posfinish { 1 -0.2 motion } bind def
X	/m0 { 0.5 dup motion } bind def
X	/m2 { 2 0 motion } bind def
X	/m3 { 3 0 motion } bind def
X	/m4 { 4 0 motion } bind def
X	/m5 { 5 0 motion } bind def
X	/m6 { 6 0 motion } bind def
X	/m7 { 7 0 motion } bind def
X	/m8 { 8 0 motion } bind def
X	/m9 { 0 1 motion } bind def
X	/m-1 { -1 0 motion } bind def
X	/underbar { 1000 0 -40 -40 1040 40 setcachedevice 80 setlinewidth
X		1 setlinecap 0 0 moveto 1000 0 lineto stroke } bind def
X	/sidebar { 0 0 setcharwidth 80 setlinewidth
X		1 setlinecap 0 0 moveto 0 1000 lineto stroke } bind def
X	/wblock { 0 0 setcharwidth setW
X		200 200 moveto 600 0 rlineto 0 600 rlineto -600 0 rlineto
X		fill } bind def
X
% Informant symbols
X
X	/plusequals { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		100 10 moveto 800 0 rlineto 0 140 Rmoveto -800 0 rlineto
X		0 300 Rmoveto 800 0 rlineto 500 150 moveto 0 650 rlineto
X		stroke } bind def
X
X	/equalsplus { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		100 790 moveto 800 0 rlineto 0 -140 Rmoveto -800 0 rlineto
X		0 -300 Rmoveto 800 0 rlineto 500 0 moveto 0 650 rlineto
X		stroke } bind def
X
X	/plusorminus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 800 0 rlineto 0 385 Rmoveto -800 0 rlineto
X		500 0 moveto 0 800 rlineto stroke } bind def
X
X	/minusorplus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 785 moveto 800 0 rlineto 0 -385 Rmoveto -800 0 rlineto
X		500 0 moveto 0 800 rlineto stroke } bind def
X
X	/plus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 400 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
X		stroke } bind def
X
X	/minus { 1000 0 100 385 900 415 setcachedevice 30 setlinewidth
X		100 400 moveto 800 0 rlineto stroke } bind def
X
X	/equal { 1000 0 100 300 800 180 Round
X		320 add exch 100 add exch setcachedevice 20 setlinewidth
X		100 310 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
X		stroke } bind def
X
X	/infinity { 1000 0 95 60 905 540 setcachedevice 40 setlinewidth
X		275 300 160 0 360 arc 660 300 225 -180 180 arc stroke
X		} bind def
X
X	/infinityequals { 1000 0 95 10 905 750 setcachedevice 30 setlinewidth
X		275 250 160 0 360 arc 660 250 225 -180 180 arc
X		100 565 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
X		stroke } bind def
X
X	/circarrow {1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		500 400 385 0 30 arcn -200 0 rmoveto 200 0 rlineto
X		0 200 rlineto stroke } bind def
X
X	/circledot { 900 0 100 0 800 700 setcachedevice 20 setlinewidth
X		450 350 20 0 360 arc fill 450 350 340 0 360 arc stroke
X		} bind def
X
X	/rightarrow { 1200 0 100 185 1115 615 setcachedevice 30 setlinewidth
X		100 400 moveto 1000 0 rlineto -200 -200 rmoveto 200 200 rlineto
X		-200 200 rlineto stroke } bind def
X
X	/uparrow { 500 0 35 0 465 915 setcachedevice 30 setlinewidth
X		250 0 moveto 0 900 rlineto -200 -200 rmoveto 200 200 rlineto
X		200 -200 rlineto stroke } bind def
X
X	/botharrow { 1200 0 100 70 1100 730 setcachedevice 20 setlinewidth
X		100 280 moveto 990 0 rlineto -200 -200 rmoveto 200 200 rlineto
X		-200 200 rlineto 1100 520 moveto -990 0 rlineto
X		200 -200 rmoveto -200 200 rlineto 200 200 rlineto
X		stroke } bind def
X
X	/circlebolddot { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		500 400 50 0 360 arc fill 500 400 390 0 360 arc stroke
X		} bind def
X
X	/hash { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 280 moveto 800 0 rlineto 0 240 Rmoveto -800 0 rlineto
X		380 0 moveto 0 800 rlineto 240 0 Rmoveto 0 -800 rlineto
X		stroke } bind def
X
X	/triangle { 900 0 100 0 800 750 setcachedevice 30 setlinewidth
X		100 15 moveto 350 735 rlineto 350 -735 rlineto
X		closepath stroke } bind def
X
X	/square { 900 0 100 0 680 680 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 680 0 Rlineto 0 680 Rlineto
X		-680 0 Rlineto closepath stroke } bind def
X
X	/semicircle { 1000 0 50 0 950 465 setcachedevice 30 setlinewidth
X		500 15 435 0 180 arc closepath stroke } bind def
X
X	/line { 1000 0 100 190 900 610 setcachedevice 20 setlinewidth
X		220 300 moveto 560 0 rlineto 0 200 Rmoveto -560 0 rlineto
X		310 200 moveto -200 200 rlineto 200 200 rlineto
X		690 200 moveto 200 200 rlineto -200 200 rlineto
X		stroke } bind def
X
X	/diags { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		110 120 moveto 670 dup rlineto 110 -110 Rmoveto
X		-670 dup rlineto 640 790 moveto 250 0 rlineto
X		0 -250 rlineto stroke } bind def
X
X	/centre { 1000 0 100 0 780 780 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 780 0 Rlineto 0 780 Rlineto -780 0 Rlineto
X		closepath 110 400 moveto 780 0 rlineto 500 10 moveto
X		0 780 Rlineto stroke } bind def
X
X	/kside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
X		110 10 moveto 300 390 rlineto -300 390 rlineto
X		180 0 Rmoveto 300 -390 rlineto -300 -390 rlineto
X		stroke } bind def
X
X	/qside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
X		590 10 moveto -300 390 rlineto 300 390 rlineto
X		-180 0 Rmoveto -300 -390 rlineto 300 -390 rlineto
X		stroke } bind def
X
X	/weakpt { 700 0 100 0 600 500 setcachedevice 30 setlinewidth
X		110 10 moveto 480 480 rlineto 590 10 moveto -480 480 rlineto
X		stroke } bind def
X
X	/ending { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
X		stroke } bind def
X
X	/bpair { 1200 0 100 0 980 580 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
X		closepath 110 10 moveto 980 580 Rmoveto -570 0 Rlineto
X		0 -370 Rlineto 570 0 Rlineto closepath stroke } bind def
X
X	/oppbs { 1200 0 100 0 1100 600 setcachedevice 20 setlinewidth
X		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
X		closepath stroke 1100 600 moveto -590 0 rlineto
X		0 -390 rlineto 590 0 rlineto fill } bind def
X
X	/samebs { 1200 0 100 0 1100 600 setcachedevice
X		100 0 moveto 590 0 rlineto 0 390 rlineto -590 0 rlineto
X		closepath 1100 600 moveto -590 0 rlineto 0 -390 rlineto
X		590 0 rlineto fill } bind def
X
X	/united { 1210 0 50 0 1160 530 setcachedevice 30 setlinewidth
X		315 265 250 0 360 arc stroke 895 265 250 0 360 arc
X		stroke } bind def
X
X	/separated { 1550 0 50 0 1500 530 setcachedevice 30 setlinewidth
X		315 265 250 0 360 arc stroke 1235 265 250 0 360 arc stroke
X		665 30 60 0 360 arc fill 885 30 60 0 360 arc fill } bind def
X
X	/doubled { 730 0 100 0 630 1160 setcachedevice 30 setlinewidth
X		365 265 250 0 360 arc stroke 365 895 250 0 360 arc
X		stroke } bind def
X
X	/tempo { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		110 400 moveto 500 400 390 0 360 arc 500 10 moveto
X		0 790 rlineto stroke } bind def
X
X	/with { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 800 moveto 0 -785 rlineto 785 0 rlineto stroke } bind def
X
X	/without { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 785 0 rlineto 0 785 rlineto stroke } bind def
X
X	/etc { 500 0 100 0 270 800 Round
X		exch 130 add exch setcachedevice 30 setlinewidth
X		115 0 moveto 0 800 rlineto 270 0 Rmoveto 0 -800 rlineto
X		stroke } bind def
end def
X
/BuildChar { exch begin CharProcs begin
X	{ SetChar } stopped not { DoChar } if
X	end end } bind def
end def
X
/ChessFont Cfont definefont pop
% Demo file to be appended to the Chess Font file & sent to your LaserWriter
%	(or whatever else you do with PostScript!).
X
% Miscellaneous useful procedures:
X
X	% show string centred on the current point
/cshow { dup stringwidth -2 div exch -2 div exch rmoveto show } bind def
X
X	% Draw rank and file labels round a standard diagram
X	%   On entry, the ChessFont must be currently selected,
X	%   and the (properly scaled) font desired for the labels
X	%   must be top of stack.  Uses "cshow", defined above
/dolabels {
X	('[<0) show			% position of top-left label
X	(0) stringwidth -1.5 div	% 1/3-square offset
X	0 exch rmoveto exch		% restore labelfont to top of stack
X	[(8)(7)(6)(5)(4)(3)(2)(1)]	% rank labels
X	{ gsave exch			% stack == offset, label, labelfont
X		dup setfont exch cshow
X	  grestore
X	  (8;) show			% move down a rank
X	} forall
X	[(a)(b)(c)(d)(e)(f)(g)(h)]	% file labels
X	{ (>) show			% move along a file
X	  gsave exch			% as before
X		dup setfont exch cshow
X	  grestore
X	} forall pop			% zap the labelfont
X	(0]') show			% move to RHS of board
X	1.5 div 0 exch rmoveto		% undo previous offset
} bind def
X
X	% Rotate a piece.  The piece [eg "(Q)"] and the desired rotation
X	%   (in degrees, anticlockwise) should be on the stack
/twirl {
X	gsave			% keep graphics state
X		(0) show	% go to centre of square
X		rotate		% no of degrees was on stack
X		(07;) show	% back to bottom left of rotated square --
X				% "0" takes us from centre to top right, "7"
X				% advances 7 squares, ";" goes down one and
X				% back 8
X		show		% string was on stack
X	grestore		% restore graphics state
X	( ) show		% advance to next square
} bind def
X
X	% Draw a neutral piece (for Fairy chess).  Expects two strings
X	%   [eg. "(R) (r)"] on the stack;  the first will be drawn in
X	%   the left half of the square, the second in the right half.
/neutral {
X	2 dict begin			% small dictionary for xinc, yinc
X	gsave				% keep graphics state
X		(0) stringwidth		% distance to centre of square
X		/yinc exch 2 mul def
X		/xinc exch def
X		currentpoint
X		xinc 0 rlineto		% draw clipping rectangle round
X		0 yinc rlineto		% left half of square
X		xinc neg 0 rlineto clip
X		moveto show		% show left half-piece
X	grestore gsave			% cancel clip
X		currentpoint
X		xinc 0 rmoveto
X		xinc 0 rlineto		% clip right half of square
X		0 yinc rlineto
X		xinc neg 0 rlineto clip
X		moveto show		% show right half-piece
X	grestore			% restore graphics state
X	( ) show			% advance to next square
X	end				% close small dictionary
} bind def
X
% End of generally useful procedures.
X
% Quick hack definitions for this file:
X
% Miscellaneous definitions:
X
/ps 10.5 def		% point size
/vs 12.5 def		% vertical spacing
/V 11 72 mul def	% top margin
/L 40 def		% left margin
X
/N { L V vs sub dup /V exch def moveto } bind def	% newline
/T { currentpoint exch L sub 6 add 36 div ceiling 36 mul L add exch moveto }
X	bind def	% tab
X
X	% Switch into Chess/Times/Courier/Bold
/C { /ChessFont findfont ps scalefont setfont } bind def
/R { /Times-Roman findfont ps scalefont setfont } bind def
/H { /Courier findfont ps scalefont setfont } bind def
/B { /Times-Bold findfont ps 1.25 mul scalefont setfont } bind def
X
X	12345		% pseudo-random item on stack, as check
SHAR_EOF
chmod 0664 ChessFont ||
echo 'restore of ChessFont failed'
Wc_c="`wc -c < 'ChessFont'`"
test 28062 -eq "$Wc_c" ||
	echo 'ChessFont: original size 28062, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= MAN-PAGE ==============
if test -f 'MAN-PAGE' -a X"$1" != X"-c"; then
	echo 'x - skipping MAN-PAGE (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting MAN-PAGE (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'MAN-PAGE' &&
.TH Chess GNU
.SH NAME
Chess \- GNU Chess
.SH SYNOPSIS
.B Chess
[
.B [-t] [-c size] [-s pathname] [-l pathname] arg1 arg2
]
.SH DESCRIPTION
.I Chess
plays a game of chess against the user or it plays against itself.
.PP
.I Chess
has a simple alpha-numeric board display or it can be compiled for
use with the CHESSTOOL program on a SUN workstation.
The program gets its opening moves from the file gnuchess.book which
should be located in the same directory as gnuchess.
To invoke the prgram, type 'gnuchess' or type 'chesstool gnuchess'
on a SUN workstation where 'CHESSTOOL' is installed.
The 'gnuchess' command can be followed by up to 2 command line arguments.
If one argument is given it determines the programs search time in
seconds.  If two arguments are given, they will be used to set tournament
time controls with the first argument being the number of moves and the second
being the total clock time in minutes.  Thus, entering 'chess 60 5' will set
the clocks for 5 minutes (300 seconds) for the first 60 moves.
If no argument is given the program will prompt the user for level of
play.
For use with CHESSTOOL, see the documentation on that program.
.PP
Once
.I Chess
is invoked, the program will display the board and prompt the user
for a move. To enter a move, use the notation 'e2e4' where the first
letter-number pair indicates the origination square
and the second letter-number pair indicates the destination square.
An alternative is to use the notation 'nf3' where
the first letter indicates the piece type (p,n,b,r,q,k).
To castle, type the origin and destination squares
of the king just as you would do for a regular move, or type
"o-o" for kingside castling and "o-o-o" for queenside.
To promote a pawn append the type of the new piece to the move, as in 
e7e8q or c7c8r.
.SH "FUNCTION LETTERS"
.TP
.B t
Show statistics for HASHFILE
.TP
.B c size
Create a new HASHFILE. File size is 2^size bytes.
.TP
.B s pathname
Pathname of the save file to use with the
.BR save
command.
.TP
.B l pathname
Pathname of the loadfile use with the
.BR get
or
.BR xget.
.SH COMMANDS
.PP
In addition to legal moves, the following commands are available as responses.
.PP
.I Awindow
-- change Alpha window (default score + 90)
.PP
.I Bwindow
-- change Beta window (default score - 90)
.PP
.I beep
-- causes the program to beep after each move.
.PP
.I bd
-- updates the current board position on the display.
.PP
.I book
-- turns off use of the opening library.
.PP
.I both
-- causes the computer to play both sides of a chess game.
.PP
.I black
-- causes the computer to take the black pieces 
.PP
.I level
-- allows the user to set time controls such as
60 moves in 5 minutes etc.  In tournament mode, the program will
vary the time it takes for each
move depending on the situation.  If easy mode is disabled (using
the 'easy' command), the program
will often respond with its move immediately, saving time on
its clock for use later on.
.PP
.I debug
--  asks for a piece as color piece, as wb or bn, and shows its calculated value on
each square.
.PP
.I depth
-- allows the user to change the
search depth of the program.  The maximum depth is 29 ply.
Normally the depth is set to 29 and the computer terminates
its search based on elapsed time rather than depth.
Using the depth command allows setting depth to say
4 ply and setting response time to a large number such as
9999 seconds. The program will then search until all moves
have been examined to a depth of 4 ply (with extensions up
to 11 additional ply for sequences of checks and captures). 
.PP
.I easy
-- toggles easy mode (thinking on opponents time)
on and off. The default is easy mode ON.  If easy mode is disabled,
the user must enter a 'break' or '^C' to get the programs
attention before entering each move.
.PP
.I edit
-- allows the user to set up a board position.
In this mode, the '#' command will clear the board, the 'c'
command will toggle piece color, and the '.' command will exit
setup mode.  Pieces are entered by typing a letter (p,n,b,r,q,k) for
the piece followed by the coordinate.  For example "pb3" would
place a pawn on square b3.
.PP
.I first
-- tells the computer to move first. Computer begins searching for a move.
(same as "go").
.PP
.I force
-- allows the user to enter moves for both
sides. To get the program to play after a sequence of moves
has been entered use the 'white' or 'black' commands.
.PP
.I get
-- retrieves a game from disk.  The program will
prompt the user for a file name.
.PP
.I hashdepth
-- allows the user to change the minimum depth for using the hashfile and the number of moves from the
begining of the game to use it.
.PP
.I help
-- displays a short description of the commands.
.PP
.I go
-- tells the computer to move first. Computer begins searching for a move.
(same as "first").
.PP
.I hint
-- causes the program to supply the user with its predicted move.
.PP
.I list
-- writes the game moves and some statistics
on search depth, nodes, and time to the file 'chess.lst'.
.PP
.I new
-- starts a new game.
.PP
.I p
-- evaluates the board and shows the point score for each piece. The total score for
a position is the sum of these individual piece scores.
.PP
.I post
-- causes the program to display the principle
variation and the score during the search.  A score of
100 is equivalent to a 1 pawn advantage for the computer.
.PP
.I random
-- causes the program to randomize its move
selection slightly.
.PP
.I reverse
-- causes the board display to be reversed.  That
is, the white pieces will now appear at the top of the board.
.PP
.I test
-- performs some speed tests for MoveList and CaptureList processing. 
.PP
.I quit
-- exits the game.
.PP
.I save
-- saves a game to disk.  The program will prompt
the user for a file name.
.PP
.I switch
-- causes the program to switch places with
the opponent and begin searching.
.PP
.I undo
-- undoes the last move whether it was the computer's
or the human's. You may also type "remove". This is equivalent
to two "undo's" (e.g. retract one move for each side).
.PP
.I white
-- causes the computer to take the white pieces
.PP
.I xwndw
-- change X window. The window around alpha/beta used to determine whether the position
should be scored or just estimated.
.SH BUGS
.PP
Pawn promotion to pieces other than a queen is not allowed.
En-Passant does not work properly with CHESSTOOOL.
The transposition table may not work properly in some
positions so the default is to turn this off. 
.fi
.SH SEE ALSO
.nf
chesstool(6)
.fi
X
SHAR_EOF
chmod 0664 MAN-PAGE ||
echo 'restore of MAN-PAGE failed'
Wc_c="`wc -c < 'MAN-PAGE'`"
test 6506 -eq "$Wc_c" ||
	echo 'MAN-PAGE: original size 6506, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
#
# Makefile for CHESS
#
# Copyright (C) 1986, 1987, 1988, 1989, 1990 Free Software Foundation, Inc.
#
# This file is part of CHESS.
#
# CHESS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY.  No author or distributor
# accepts responsibility to anyone for the consequences of using it
# or for whether it serves any particular purpose or works at all,
# unless he says so in writing.  Refer to the CHESS General Public
# License for full details.
#
# Everyone is granted permission to copy, modify and redistribute
# CHESS, but only under the conditions described in the
# CHESS General Public License.   A copy of this license is
# supposed to have been given to you along with CHESS so you
# can know your rights and responsibilities.  It should be in a
# file named COPYING.  Among other things, the copyright notice
# and this notice must be preserved on all copies.
#
# gnuchess  will be the curses-based chess.
# gnuchessn will be the fancy-display-curses-based chess.
# gnuchessr will be the xchess/chesstool based chess.
#		(/usr/games/chesstool gnuchessr)
#    for use with SUN's chesstool and X-window's xchess.
#    To use with latter, add -DCHESSTOOL to the nondsp.o
#    compilation lines (e.g. cc -O -DCHESSTOOL ...)
# If you want to use the persistent transpositon table add
# -DHASHFILE=\"$(LIBDIR)/gnuchess.hash\"
# to the gnuchess.o compilation line. You also have to run gnuchess -t
# To actually create the file. -t can also be used to report
# statistics about the file or to resize it.
#
VERS=	3.1
DIST=	README DOCUMENTATION Makefile Makefile.dos version.h\
X	gnuchess.h gnuchess.c\
X	uxdsp.c nondsp.c nuxdsp.c gnuchess.book Xchess
BINDIR= /usr/local/bin
LIBDIR= /usr/local/lib
LCURSES=-lcurses -ltermcap
HASH=	-DHASHFILE=\"$(LIBDIR)/gnuchess.hash\"
BOOK=	-DBOOK=\"$(LIBDIR)/gnuchess.book\"
#CC= cc
CC=	gcc -W
#CFLAGS= -O -Dinline=""		# for Aviion gcc-1.35
CFLAGS=	-O -finline-functions -fstrength-reduce
X
all : gnuchess gnuchessr gnuchessn postprint gnuan
X
gnuchess: gnuchess.o uxdsp.o
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchess gnuchess.o uxdsp.o $(LCURSES)
X
gnuan: gnuchess.o gnuan.o
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuan gnuchess.o gnuan.o
X
gnuchessr: gnuchess.o nondsp.o
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuchessr gnuchess.o nondsp.o
X
gnuchessn: gnuchess.o nuxdsp.o
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchessn gnuchess.o nuxdsp.o $(LCURSES)
X	
postprint: postprint.o
X	$(CC) $(CFLAGS) -o postprint postprint.o
X	
gnuchessd: gnuchess.c nuxdsp.c
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -DDEBUG -o  gnuchessd  nondsp.c gnuchess.c
X	rm nondsp.o gnuchess.o
X
gnuan.o: gnuan.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c gnuan.c
X
gnuchess.o: gnuchess.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c gnuchess.c
X
uxdsp.o: uxdsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c uxdsp.c
X
nuxdsp.o: nuxdsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c nuxdsp.c
X
nondsp.o: nondsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -c nondsp.c
X
postprint.o: postprint.c gnuchess.h version.h
X	$(CC) $(CFLAGS) -c postprint.c
X
lint:
X	lint gnuchess.c uxdsp.c nondsp.c nuxdsp.c
X
unprotoize:
X	unprotoize -c -DHASHFILE gnuchess.c uxdsp.c nondsp.c nuxdsp.c
X
protoize:
X	protoize -c -DHASHFILE gnuchess.c uxdsp.c nondsp.c nuxdsp.c
X
distribution:
X	tar cf - $(DIST) > gnuchess.tar
X	compress gnuchess.tar
X	mv gnuchess.tar.Z gnuchess-$(VERS).tar.Z
X
install:
X	cp gnuchessr $(BINDIR)/gnuchess
X	cp gnuchess $(BINDIR)/gnuchess
X	cp gnuchess.book $(LIBDIR)/gnuchess.book
X
clean:
X	-rm gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan *.o
SHAR_EOF
chmod 0664 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 3665 -eq "$Wc_c" ||
	echo 'Makefile: original size 3665, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.dos ==============
if test -f 'Makefile.dos' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.dos (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.dos (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.dos' &&
# makefile.dos -  Makefile for CHESS (MS-DOS Version)
# Copyright (C) 1990 by Thorsten Ohl, td12@ddagsi3.bitnet
# Copyright (C) 1986, 1987, 1988, 1989, 1990 Free Software Foundation, Inc.
#
# This makefile will NOT work with Microsoft's make.
# Use a **IX compatible make instead.
#
# This file is not yet part of CHESS.
#
# CHESS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY.  No author or distributor
# accepts responsibility to anyone for the consequences of using it
# or for whether it serves any particular purpose or works at all,
# unless he says so in writing.  Refer to the CHESS General Public
# License for full details.
#
# Everyone is granted permission to copy, modify and redistribute
# CHESS, but only under the conditions described in the
# CHESS General Public License.   A copy of this license is
# supposed to have been given to you along with CHESS so you
# can know your rights and responsibilities.  It should be in a
# file named COPYING.  Among other things, the copyright notice
# and this notice must be preserved on all copies.
X
# gnuchess  will be the curses-based chess.
# gnuchessn will be the fancy-display-curses-based chess.
# gnuchessr will be the xchess/chesstool based chess.
#		(/usr/games/chesstool gnuchessr)
#    for use with SUN's chesstool and X-window's xchess.
#    To use with latter, add -DCHESSTOOL to the nondsp.o
#    compilation lines (e.g. cc -O -DCHESSTOOL ...)
# If you want to use the persistent transpositon table add
# -DHASHFILE=\"$(LIBDIR)/gnuchess.hash\"
# to the gnuchess.o compilation line. You also have to run gnuchess -t
# To actually create the file. -t can also be used to report
# statistics about the file or to resize it.
X
# if you don't want the IBM PC's graphic characters, add -DSEVENBIT
CC	=cl
BINDIR	=.
LIBDIR	=.
HASH	=-DHASHFILE=\"$(LIBDIR)/gnuchess.hash\"
BOOK	=-DBOOK=\"$(LIBDIR)/gnuchess.book\"
SHAR_EOF
true || echo 'restore of Makefile.dos failed'
fi
echo 'End of  part 1'
echo 'File Makefile.dos is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
-- 
Kent Landfield                   INTERNET: kent@sparky.IMD.Sterling.COM
Sterling Software, IMD           UUCP:     uunet!sparky!kent
Phone:    (402) 291-8300         FAX:      (402) 291-4362
Please send comp.sources.misc-related mail to kent@uunet.uu.net.


