From pa.dec.com!decwrl!uunet!sparky!kent Sun May 19 12:34:25 PDT 1991
Article: 2358 of comp.sources.misc
Newsgroups: comp.sources.misc
Path: pa.dec.com!decwrl!uunet!sparky!kent
From: Mike McGann <mwm@hasler.ascom.ch>
Subject:  v19i078:  gnuchess - gnuchess version 3.1+, Part06/07
Message-ID: <1991May17.024537.27858@sparky.IMD.Sterling.COM>
X-Md4-Signature: a83dd09c3b844185432892faacc0ef77
Sender: kent@sparky.IMD.Sterling.COM (Kent Landfield)
Organization: Sterling Software, IMD
Date: Fri, 17 May 1991 02:45:37 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Mike McGann <mwm@hasler.ascom.ch>
Posting-number: Volume 19, Issue 78
Archive-name: gnuchess/part06

#!/bin/sh
# do not concatenate these parts, unpack them in order with /bin/sh
# file nuxdsp.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping nuxdsp.c'
else
echo 'x - continuing file nuxdsp.c'
sed 's/^X//' << 'SHAR_EOF' >> 'nuxdsp.c' &&
X    40x24 two-colour display
X	option for shading black squares
X	expanded game save, list, and restore features using $HOME
X	option to disable display of coordinates
X	optional auto-updating of positional information
X	optional starring of black side
X	mass toggle for reverse-video functions
X
X  This file is part of CHESS.
X
X  CHESS is distributed in the hope that it will be useful, but WITHOUT ANY
X  WARRANTY.  No author or distributor accepts responsibility to anyone for
X  the consequences of using it or for whether it serves any particular
X  purpose or works at all, unless he says so in writing.  Refer to the CHESS
X  General Public License for full details.
X
X  Everyone is granted permission to copy, modify and redistribute CHESS, but
X  only under the conditions described in the CHESS General Public License.
X  A copy of this license is supposed to have been given to you along with
X  CHESS so you can know your rights and responsibilities.  It should be in a
X  file named COPYING.  Among other things, the copyright notice and this
X  notice must be preserved on all copies.
*/
X
X
#include <ctype.h>
#include <signal.h>
#ifdef MSDOS
#include <dos.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
X
#define ESC 0x1B
#define scanz scanf
#define printz printf
#define refresh() fflush(stdout)
X
int mycntl1, mycntl2;
static void param (short n);
#else
#include <sys/param.h>
#include <sys/types.h>
#include <sys/file.h>
#include <curses.h>
X
#define scanz fflush(stdout),scanw
#define printz printw
X
/* <stdlib.h> */
extern void *malloc (size_t);
extern void exit (int);
/* <string.h> */
extern char *strcat (char *, const char *);
extern int strcmp (const char *, const char *);
extern char *strcpy (char *, const char *);
/* <time.h> */
extern long int time (long int *);
#endif /* MSDOS */
X
#include "gnuchess.h"
X
#define pxx " PNBRQK"
#define qxx " pnbrqk"
#define rxx "12345678"
#define cxx "abcdefgh"
#define TAB (43)
/* coordinates within a square for the following are ([1,5],[1,3]) */
#define SQW (5)
#define SQH (3)
#define VIR_C(s)  ((flag.reverse) ? 7-column(s) : column(s))
#define VIR_R(s)  ((flag.reverse) ? 7-row(s) : row(s))
#define VSQ_X(x)  ((flag.reverse) ? SQW + 1 - (x) : (x))
#define VSQ_Y(y)  ((flag.reverse) ? SQH + 1 - (y) : (y))
#define Vblack(s) (!((VIR_C(s) + VIR_R(s)) % 2))
/* Squares swapped */
#define Vcoord(s,x,y) \
X	((SQW)*(VIR_C(s)))+(x),((SQH)*(7-VIR_R(s))+(y))
/* Squares and internal locations swapped */
#define VcoordI(s,x,y) \
X	((SQW)*(VIR_C(s)))+(VSQ_X(x)),((SQH)*(7-VIR_R(s))+(VSQ_Y(y)))
/* Squares and internal rows swapped */
#define VcoordR(s,x,y) \
X	((SQW)*(VIR_C(s)))+(x),((SQH)*(7-VIR_R(s))+(VSQ_Y(y)))
char Analysis[128] = "";
short int MV[maxdepth];
int MSCORE;
char *DRAW;
char mvstr[4][6];
static char *ColorStr[2] =
{"White", "Black"};
static long evrate;
short PositionFlag = 0;
short coords = 1;
#if defined(MSDOS) && !defined(SEVENBIT)
short rv = 0;
static void ONormal (void);
static void OReverse (void);
#else
short stars = 0;
short rv = 1;
short shade = 0;
#endif /* MSDOS && !SEVENBIT */
X
extern char *getenv (const char *);
void TerminateSearch (int), Die (int);
X
void
Initialize (void)
{
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
X  initscr ();
X  crmode ();
#else
X  mycntl1 = mycntl2 = 0;
#endif /* MSDOS */
}
X
void
ExitChess (void)
{
X  ListGame ();
X  gotoXY (1, 24);
#ifndef MSDOS
X  nocrmode ();
X  endwin ();
#endif /* MSDOS */
X  exit (0);
}
X
void
Die (int Sig)
{
X  char s[80];
X
X  signal (SIGINT, SIG_IGN);
#ifdef MSDOS
X  Sig++;			       /* shut up the compiler */
#else
X  signal (SIGQUIT, SIG_IGN);
#endif /* MSDOS */
X  ShowMessage ("Abort? ");
X  scanz ("%s", s);
X  if (strcmp (s, "yes") == 0)
X    ExitChess ();
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
#endif /* MSDOS */
}
X
void
TerminateSearch (int Sig)
{
X  signal (SIGINT, SIG_IGN);
#ifdef MSDOS
X  Sig++;			       /* shut up the compiler */
#else
X  signal (SIGQUIT, SIG_IGN);
#endif /* MSDOS */
X  flag.timeout = true;
X  flag.bothsides = false;
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
#endif /* MSDOS */
}
void 
ShowLine (short unsigned int *bstline)
{
}
X
void
algbr (short int f, short int t, short int flag)
X
/*
X   Generate move strings in different formats.
*/
X
{
X  int m3p;
X
X  if (f != t)
X    {
X      /* algebraic notation */
X      mvstr[0][0] = cxx[column (f)];
X      mvstr[0][1] = rxx[row (f)];
X      mvstr[0][2] = cxx[column (t)];
X      mvstr[0][3] = rxx[row (t)];
X      mvstr[0][4] = mvstr[3][0] = '\0';
X      if (((mvstr[1][0] = pxx[board[f]]) == 'P') || (flag & promote))
X	{
X	  if (mvstr[0][0] == mvstr[0][2])	/* pawn did not eat */
X	    {
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][2];	/* to column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][3];	/* to row */
X	      m3p = 2;
X	    }
X	  else
X	    /* pawn ate */
X	    {
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][0];	/* from column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][2];	/* to column */
X	      mvstr[2][2] = mvstr[0][3];
X	      m3p = 3;		       /* to row */
X	    }
X	  mvstr[2][m3p] = mvstr[1][2] = '\0';
X	  if (flag & promote)
X	    {
X	      mvstr[0][4] = mvstr[1][2] = mvstr[2][m3p] = qxx[flag & pmask];
X	      mvstr[1][3] = mvstr[2][m3p + 1] = mvstr[0][5] = '\0';
X	    }
X	}
X      else
X	/* not a pawn */
X	{
X	  mvstr[2][0] = mvstr[1][0];
X	  mvstr[2][1] = mvstr[0][1];
X	  mvstr[2][2] = mvstr[1][1] = mvstr[0][2];	/* to column */
X	  mvstr[2][3] = mvstr[1][2] = mvstr[0][3];	/* to row */
X	  mvstr[2][4] = mvstr[1][3] = '\0';
X	  strcpy (mvstr[3], mvstr[2]);
X	  mvstr[3][1] = mvstr[0][0];
X	  if (flag & cstlmask)
X	    {
X	      if (t > f)
X		{
X		  strcpy (mvstr[1], "o-o");
X		  strcpy (mvstr[2], "O-O");
X		}
X	      else
X		{
X		  strcpy (mvstr[1], "o-o-o");
X		  strcpy (mvstr[2], "O-O-O");
X		}
X	    }
X	}
X    }
X  else
X    mvstr[0][0] = mvstr[1][0] = mvstr[2][0] = mvstr[3][0] = '\0';
}
X
int
VerifyMove (char *s, short int iop, short unsigned int *mv)
X
/*
X   Compare the string 's' to the list of legal moves available for the
X   opponent. If a match is found, make the move on the board.
*/
X
{
X  static short pnt, tempb, tempc, tempsf, tempst, cnt;
X  static struct leaf xnode;
X  struct leaf *node;
X
X  *mv = 0;
X  if (iop == 2)
X    {
X      UnmakeMove (opponent, &xnode, &tempb, &tempc, &tempsf, &tempst);
X      return (false);
X    }
X  cnt = 0;
X  MoveList (opponent, 2);
X  pnt = TrPnt[2];
X  while (pnt < TrPnt[3])
X    {
X      node = &Tree[pnt++];
X      algbr (node->f, node->t, (short) node->flags);
X      if (strcmp (s, mvstr[0]) == 0 || strcmp (s, mvstr[1]) == 0 ||
X	  strcmp (s, mvstr[2]) == 0 || strcmp (s, mvstr[3]) == 0)
X	{
X	  cnt++;
X	  xnode = *node;
X	}
X    }
X  if (cnt == 1)
X    {
X      MakeMove (opponent, &xnode, &tempb, &tempc, &tempsf, &tempst, &INCscore);
X      if (SqAtakd (PieceList[opponent][0], computer))
X	{
X	  UnmakeMove (opponent, &xnode, &tempb, &tempc, &tempsf, &tempst);
X	  ShowMessage ("Illegal Move!!");
X	  return (false);
X	}
X      else
X	{
X	  if (iop == 1)
X	    return (true);
X	  UpdateDisplay (xnode.f, xnode.t, 0, (short) xnode.flags);
X	  if ((board[xnode.t] == pawn)
X	      || (xnode.flags & capture)
X	      || (xnode.flags & cstlmask))
X	    {
X	      Game50 = GameCnt;
X	      ZeroRPT ();
X	    }
X	  GameList[GameCnt].depth = GameList[GameCnt].score = 0;
X	  GameList[GameCnt].nodes = 0;
X	  ElapsedTime (1);
X	  GameList[GameCnt].time = (short) et;
X	  TimeControl.clock[opponent] -= et;
X	  --TimeControl.moves[opponent];
X	  *mv = (xnode.f << 8) | xnode.t;
X	  algbr (xnode.f, xnode.t, false);
X	  return (true);
X	}
X    }
X  if (cnt > 1)
X    ShowMessage ("Ambiguous Move!");
X  return (false);
}
X
void
help (void)
{
X  ClrScreen ();
X  printz ("CHESS command summary\n");
X  printz ("g1f3     move from g1 to f3      quit      Exit Chess\n");
X  printz ("Nf3      move knight to f3       beep      on/off\n");
X  printz ("o-o      castle king side        easy      on/off\n");
X  printz ("o-o-o    castle queen side       hash      on/off\n");
X  printz ("bd       redraw board            reverse   board display\n");
X  printz ("list     game to chess.lst       book      on/off\n");
X  printz ("undo     undo last ply           remove    take back a move\n");
X  printz ("edit     edit board              force     enter game moves\n");
X  printz ("switch   sides with computer     both      computer match\n");
X  printz ("white    computer plays white    black     computer plays black\n");
X  printz ("depth    set search depth        level     select level\n");
X  printz ("post     principle variation     hint      suggest a move\n");
X  printz ("save     game to file            get/xget  game from file\n");
X  printz ("random   randomize play          new       start new game\n");
X  printz ("rv       toggle reverse video    coords    toggle coords\n");
#if !defined(MSDOS) || defined(SEVENBIT)
X  printz ("shade    toggle shade black      stars     toggle stars\n");
#endif /* !MSDOS || SEVENBIT */
X  printz ("p        show coordinate values\n");
X  gotoXY (10, 21);
X  printz ("Computer: %s", ColorStr[computer]);
X  gotoXY (10, 22);
X  printz ("Opponent: %s", ColorStr[opponent]);
X  gotoXY (10, 23);
X  printz ("Level: %ld", Level);
X  gotoXY (10, 24);
X  printz ("Easy mode: %s", (flag.easy) ? "ON" : "OFF");
X  gotoXY (40, 21);
X  printz ("Depth: %d", MaxSearchDepth);
X  gotoXY (40, 22);
X  printz ("Random: %s", (dither) ? "ON" : "OFF");
X  gotoXY (40, 23);
X  printz ("Transposition table: %s", (flag.hash) ? "ON" : "OFF");
X  gotoXY (40, 24);
X  printz ("Hit <RET> to return: ");
X  refresh ();
X  fflush (stdin);
X  getchar ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
}
X
void
EditBoard (void)
X
/*
X  Set up a board position. Pieces are entered by typing the piece
X  followed by the location. For example, Nf3 will place a knight on
X  square f3.
*/
X
{
X  short a, r, c, sq, i;
X  char s[80];
X
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X  gotoXY (TAB, 3);
X  printz (".   Exit to main");
X  gotoXY (TAB, 4);
X  printz ("#   Clear board");
X  gotoXY (TAB, 5);
X  printz ("c   Change sides");
X  gotoXY (TAB, 7);
X  printz ("Enter piece & location: ");
X  a = white;
X  do
X    {
X      gotoXY (TAB, 6);
X      printz ("Editing: %s", ColorStr[a]);
X      gotoXY (TAB + 24, 7);
X      ClrEoln ();
X      scanz ("%s", s);
X      if (s[0] == '#')
X	{
X	  for (sq = 0; sq < 64; sq++)
X	    {
X	      board[sq] = no_piece;
X	      color[sq] = neutral;
X	      DrawPiece (sq);
X	    }
X	}
X      if (s[0] == 'c' || s[0] == 'C')
X	a = otherside[a];
X      c = s[1] - 'a';
X      r = s[2] - '1';
X      if ((c >= 0) && (c < 8) && (r >= 0) && (r < 8))
X	{
X	  sq = locn (r, c);
X	  for (i = king; i > no_piece; i--)
X	    if ((s[0] == pxx[i]) || (s[0] == qxx[i]))
X	      break;
X	  board[sq] = i;
X	  color[sq] = (board[sq] == no_piece) ? neutral : a;
X	  DrawPiece (sq);
X	}
X  } while (s[0] != '.');
X
X  for (sq = 0; sq < 64; sq++)
X    Mvboard[sq] = (board[sq] != Stboard[sq]) ? 10 : 0;
X  GameCnt = 0;
X  Game50 = 1;
X  ZeroRPT ();
X  Sdepth = 0;
X  InitializeStats ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
}
X
void
ShowPlayers (void)
{
X  gotoXY (TAB, ((flag.reverse) ? 23 : 2));
X  printz ("%s", (computer == black) ? "Computer" : "Human   ");
X  gotoXY (TAB, ((flag.reverse) ? 2 : 23));
X  printz ("%s", (computer == white) ? "Computer" : "Human   ");
}
X
void
ShowDepth (char ch)
{
X  gotoXY (TAB, 4);
X  printz ("Depth= %d%c ", Sdepth, ch);
X  ClrEoln ();
}
X
void
ShowScore (short score)
{
X  gotoXY (TAB, 5);
X  printz ("Score= %d", score);
X  ClrEoln ();
}
X
void
ShowMessage (char *s)
{
X  gotoXY (TAB, 6);
X  printz ("%s", s);
X  ClrEoln ();
}
X
void
ClearMessage (void)
{
X  gotoXY (TAB, 6);
X  ClrEoln ();
}
X
void
ShowCurrentMove (short int pnt, short int f, short int t)
{
X  algbr (f, t, false);
X  gotoXY (TAB, 7);
X  printz ("(%2d) %4s", pnt, mvstr[0]);
}
X
void
ShowHeader (void)
{
X  gotoXY (TAB, 10);
#ifdef MSDOS
X  printz ("GNU Chess display (MS-DOS, Mar 90)");
#else
X  printz ("GNU Chess display (Nov 89)");
#endif /* MSDOS */
}
X
void
ShowSidetoMove (void)
{
X  gotoXY (TAB, 14);
X  printz ("%2d:   %s", 1 + GameCnt / 2, ColorStr[player]);
X  ClrEoln ();
}
X
void
ShowPrompt (void)
{
X  gotoXY (TAB, 19);
X  printz ("Your move is? ");
X  ClrEoln ();
}
X
void
ShowNodeCnt (long int NodeCnt, long int evrate)
{
X  gotoXY (TAB, 21);
X  printz ("Nodes= %8ld, Nodes/Sec= %5ld", NodeCnt, evrate);
X  ClrEoln ();
}
X
void
ShowResults (short int score, short unsigned int *bstline, char ch)
{
X  unsigned char d, ply;
X  if (flag.post)
X    {
X      ShowDepth (ch);
X      ShowScore (score);
X      d = 7;
X      for (ply = 1; bstline[ply] > 0; ply++)
X	{
X	  if (ply % 4 == 1)
X	    {
X	      gotoXY (TAB, ++d);
X	      ClrEoln ();
X	    }
X	  algbr ((short) bstline[ply] >> 8, (short) bstline[ply] & 0xFF, false);
X	  printz ("%5s ", mvstr[0]);
X	}
X      ClrEoln ();
X      while (d < 13)
X	{
X	  gotoXY (TAB, ++d);
X	  ClrEoln ();
X	}
X    }
}
X
void
SearchStartStuff (short int side)
{
X  short i;
X
X  signal (SIGINT, TerminateSearch);
#ifdef MSDOS
X  side++;			       /* shut up the compiler */
#else
X  signal (SIGQUIT, TerminateSearch);
#endif /* MSDOS */
X  for (i = 4; i < 14; i++)
X    {
X      gotoXY (TAB, i);
X      ClrEoln ();
X    }
}
X
void
OutputMove (void)
{
X  int i;
X
X  UpdateDisplay (root->f, root->t, 0, (short) root->flags);
X  gotoXY (TAB, 17);
X  printz ("My move is: %s", mvstr[0]);
X  if (flag.beep)
X    putchar (7);
X  ClrEoln ();
X
X  gotoXY (TAB, 24);
X  if (root->flags & draw)
X    printz ("Drawn game! %s", DRAW);
X  else if (root->score == -9999)
X    printz ("Opponent mates!");
X  else if (root->score == 9998)
X    printz ("Computer mates!");
X  else if (root->score < -9000)
X    printz ("Opponent will soon mate!");
X  else if (root->score > 9000)
X    printz ("Computer will soon mate!");
X  ClrEoln ();
X
X  if (flag.post)
X    {
X      ShowNodeCnt (NodeCnt, evrate);
X      gotoXY (TAB, 22);
X      for (i = 1999; i >= 0 && Tree[i].f == 0 && Tree[i].t == 0; i--) ;
X      printz ("Max Tree= %5d", i);
X      ClrEoln ();
X    }
}
X
void
ElapsedTime (short int iop)
X
/*
X  Determine the time that has passed since the search was started. If
X  the elapsed time exceeds the target (ResponseTime+ExtraTime) then set
X  timeout to true which will terminate the search.
*/
X
{
X  et = time ((long *) 0) - time0;
X  if (et < 0)
X    et = 0;
X  ETnodes += 50;
X  if (et > et0 || iop == 1)
X    {
X      if (et > ResponseTime + ExtraTime && Sdepth > 1)
X	flag.timeout = true;
X      et0 = et;
X      if (iop == 1)
X	{
X	  time0 = time ((long *) 0);
X	  et0 = 0;
X	}
X      if (et > 0)
X	/* evrate used to be Nodes / cputime I dont` know why */
X	evrate = NodeCnt / (et + ft);
X      else
X	evrate = 0;
X      ETnodes = NodeCnt + 50;
X      UpdateClocks ();
X    }
}
X
void
UpdateClocks (void)
{
X  short m, s;
X  m = (short) (et / 60);
X  s = (short) (et - 60 * (long) m);
X  if (TCflag)
X    {
X      m = (short) ((TimeControl.clock[player] - et) / 60);
X      s = (short) (TimeControl.clock[player] - et - 60 * (long) m);
X    }
X  if (m < 0)
X    m = 0;
X  if (s < 0)
X    s = 0;
X  if (player == white)
X    gotoXY (60, (flag.reverse) ? 2 : 23);
X  else
X    gotoXY (60, (flag.reverse) ? 23 : 2);
X  printz ("%d:%2d   ", m, s);
X  if (flag.post)
X    ShowNodeCnt (NodeCnt, evrate);
X  refresh ();
}
X
X
void
SetTimeControl (void)
{
X  if (TCflag)
X    {
X      TimeControl.moves[white] = TimeControl.moves[black] = TCmoves;
X      TimeControl.clock[white] = TimeControl.clock[black] = 60 * (long) TCminutes;
X    }
X  else
X    {
X      TimeControl.moves[white] = TimeControl.moves[black] = 0;
X      TimeControl.clock[white] = TimeControl.clock[black] = 0;
X      Level = 60 * (long) TCminutes;
X    }
X  et = 0;
X  ElapsedTime (1);
}
X
void
gotoXY (short int x, short int y)
{
#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (y);
X  putchar (';');
X  param (x);
X  putchar ('H');
#else
X  move (y - 1, x - 1);
#endif /* MSDOS */
}
X
void
ClrScreen (void)
{
#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  putchar ('2');
X  putchar ('J');
#else
X  clear ();
#endif /* MSDOS */
X  refresh ();
}
X
void
ClrEoln (void)
{
#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  putchar ('K');
#else
X  clrtoeol ();
#endif /* MSDOS */
X  refresh ();
}
X
#ifdef MSDOS
void
param (short n)
{
X  if (n >= 10)
X    {
X      register short d, q;
X      q = n / 10;
X      d = n % 10;
X      putchar (q + '0');
X      putchar (d + '0');
X    }
X  else
X    putchar (n + '0');
}
X
#endif /* MSDOS */
X
void
OReverse ()
{
#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (7);
X  putchar ('m');
#else
X  standout ();
X  /* attron (A_REVERSE); */
#endif /* MSDOS */
}
X
void
ONormal ()
{
#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (0);
X  putchar ('m');
#else
X  standend ();
X  /* attroff (A_REVERSE);*/
#endif /* MSDOS */
}
X
void
DrawPiece (short int sq)
{
X  gotoXY (VcoordR (sq, 2, 2));
X
X  switch (color[sq])
X    {
X    case black:
X      if (rv)
X	OReverse ();
#if defined(MSDOS) && !defined(SEVENBIT)
X      printz (" %c ", pxx[board[sq]]);
#else
X      printz ((stars ? "*%c*" : " %c "), pxx[board[sq]]);
#endif /* MSDOS && !SEVENBIT */
X      ONormal ();
X      break;
X    case neutral:
#if defined(MSDOS) && !defined(SEVENBIT)
X      if (rv)
X	printz (Vblack (sq) ? "\262\262\262" : "\260\260\260");
X      else
X	printz (Vblack (sq) ? "\260\260\260" : "\262\262\262");
#else
X      if (shade)
X	printz (Vblack (sq) ? "///" : "   ");
X      else
X	{
X	  if (Vblack (sq))
X	    OReverse ();
X	  printz ("   ");
X	  ONormal ();
X	}
#endif /* MSDOS && !SEVENBIT */
X      break;
X    case white:
#if defined(MSDOS) && !defined(SEVENBIT)
X      if (!rv)
X	OReverse ();
X      printz (" %c ", pxx[board[sq]]);
X      ONormal ();
#else
X      printz (" %c ", pxx[board[sq]]);
#endif /* MSDOS && !SEVENBIT */
X      break;
X    default:
X      ShowMessage ("DrawPiece:  color[sq] err");
X      break;
X    }
}
X
void
DrawSquare (short int sq)
{
#if defined(MSDOS) && !defined(SEVENBIT)
X  if (rv)
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X    }
X  else
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X    }
#else
X  if (shade)
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "/////" : "     ");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "/////" : "     ");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "/////" : "     ");
X    }
X  else
X    {
X      if (Vblack (sq))
X	OReverse ();
X      gotoXY (Vcoord (sq, 1, 1));
X      printz ("     ");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz ("     ");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz ("     ");
X      ONormal ();
X    }
#endif /* MSDOS && !SEVENBIT */
}
X
void
DrawCoords (void)
{
X  short z;
X
X  for (z = 0; z <= 7; z++)
X    {
X      short sq;
X
X      sq = z << 3;
X      gotoXY (VcoordI (sq, 1, 1));
#if !defined(MSDOS) || defined(SEVENBIT)
X      if ((Vblack (sq) || shade) && rv)
#endif /* !MSDOS || SEVENBIT */
X	OReverse ();
X      printz ("%d", 1 + z);
X      ONormal ();
X    }
X
X  for (z = 0; z <= 7; z++)
X    {
X      short sq;
X
X      sq = z;
X      gotoXY (VcoordI (sq, SQW, SQH));
#if !defined(MSDOS) || defined(SEVENBIT)
X      if ((Vblack (sq) || shade) && rv)
#endif /* !MSDOS || SEVENBIT */
X	OReverse ();
X      printz ("%c", cxx[z]);
X      ONormal ();
X    }
X
#if !defined(MSDOS) || defined(SEVENBIT)
X  for (z = 1; z <= (8 * SQH); z++)
X    {
X      gotoXY ((8 * SQW) + 1, z);
X      printz ("|");
X    }
#endif /* MSDOS && !SEVENBIT */
}
X
void
ShowPostnValue (short int sq)
X
/*
X  must have called ExaminePosition() first
*/
X
{
X  short score;
X
X  gotoXY (VcoordR (sq, 2, 1));
X  ScorePosition (color[sq], &score);
#if !defined(MSDOS) || defined(SEVENBIT)
X  if (Vblack (sq) && !shade)
X    OReverse ();
#endif /* !MSDOS || SEVENBIT */
X
X  if (color[sq] != neutral)
X    printz ("%3d", svalue[sq]);
X  else
#if defined(MSDOS) && !defined(SEVENBIT)
X    {
X      if (rv)
X	printz (Vblack (sq) ? "\262\262\262" : "\260\260\260");
X      else
X	printz (Vblack (sq) ? "\260\260\260" : "\262\262\262");
X    }
#else
X    printz (shade && Vblack (sq) ? "///" : "   ");
#endif /* MSDOS && !SEVENBIT */
X  ONormal ();
}
X
void
ShowPostnValues (void)
{
X  short sq, score;
X
X  ExaminePosition ();
X  for (sq = 0; sq < 64; sq++)
X    ShowPostnValue (sq);
X  ScorePosition (opponent, &score);
X  ShowScore (score);
}
X
void
UpdateDisplay (short int f, short int t, short int redraw, short int isspec)
{
X  short sq;
X
X  if (redraw)
X    {
X      ShowHeader ();
X      ShowPlayers ();
X      for (sq = 0; sq < 64; sq++)
X	{
X	  DrawSquare (sq);
X	  DrawPiece (sq);
X	}
X      if (coords)
X	DrawCoords ();
X    }
X  else
X    {
X      DrawPiece (f);
X      DrawPiece (t);
X      if (isspec & cstlmask)
X	if (t > f)
X	  {
X	    DrawPiece (f + 3);
X	    DrawPiece (t - 1);
X	  }
X	else
X	  {
X	    DrawPiece (f - 4);
X	    DrawPiece (t + 1);
X	  }
X      else if (isspec & epmask)
X	{
X	  DrawPiece (t - 8);
X	  DrawPiece (t + 8);
X	}
X    }
X  if (PositionFlag)
X    ShowPostnValues ();
X  refresh ();
}
X
char *InPtr;
void 
skip ()
{
X  while (*InPtr != ' ')
X    InPtr++;
X  while (*InPtr == ' ')
X    InPtr++;
}
void 
skipb ()
{
X  while (*InPtr == ' ')
X    InPtr++;
}
int 
parser (char *f, int side)
{
X  int c1, r1, c2, r2;
X  if (f[4] == 'o')
X    if (side == black)
X      return 0x3C3A;
X    else
X      return 0x0402;
X  else if (f[0] == 'o')
X    if (side == black)
X      return 0x3C3E;
X    else
X      return 0x0406;
X  else
X    {
X      c1 = f[0] - 'a';
X      r1 = f[1] - '1';
X      c2 = f[2] - 'a';
X      r2 = f[3] - '1';
X      return (locn (r1, c1) << 8) | locn (r2, c2);
X    }
X  return (0);
}
X
void
GetGame (void)
{
X  FILE *fd;
X  char fname[256], *p;
X  int c, i, j;
X  short sq;
X  unsigned short m;
X
X  fname[0] = '\0';
X  ShowMessage ("File name: ");
X  scanz ("%s", fname);
X  if (!fname[0])
X    strcpy (fname, "chess.000");
X  ShowMessage ("Loading ");
X  printz ("%s", fname);
X
X  if ((fd = fopen (fname, "r")) == NULL)
X    {
X      ShowMessage ("Load failed");
X      return;
X    }
X
X
X  fgets (fname, 256, fd);
X  computer = opponent = white;
X  InPtr = fname;
X  skip ();
X  if (*InPtr == 'c')
X    computer = black;
X  else
X    opponent = black;
X  skip ();
X  skip ();
X  skip ();
X  Game50 = atoi (InPtr);
X  fgets (fname, 256, fd);
X  InPtr = &fname[14];
X  castld[white] = (*InPtr == 't') ? true : false;
X  skip ();
X  skip ();
X  castld[black] = (*InPtr == 't') ? true : false;
X  fgets (fname, 256, fd);
X  InPtr = &fname[11];
X  skipb ();
X  TCflag = atoi (InPtr);
X  skip ();
X  InPtr += 14;
X  skipb ();
X  OperatorTime = atoi (InPtr);
X  fgets (fname, 256, fd);
X  InPtr = &fname[11];
X  skipb ();
X  TimeControl.clock[white] = atoi (InPtr);
X  skip ();
X  skip ();
X  TimeControl.moves[white] = atoi (InPtr);
X  fgets (fname, 256, fd);
X  InPtr = &fname[11];
X  skipb ();
X  TimeControl.clock[black] = atoi (InPtr);
X  skip ();
X  skip ();
X  TimeControl.moves[black] = atoi (InPtr);
X  fgets (fname, 256, fd);
X  for (i = 7; i > -1; i--)
X    {
X      fgets (fname, 256, fd);
X      p = &fname[2];
X      InPtr = &fname[11];
X      skipb ();
X      for (j = 0; j < 8; j++)
X	{
X	  sq = i * 8 + j;
X	  if (*p == '.')
X	    {
X	      board[sq] = no_piece;
X	      color[sq] = neutral;
X	    }
X	  else
X	    {
X	      for (c = 0; c < 8; c++)
X		{
X		  if (*p == pxx[c])
X		    {
X		      board[sq] = c;
X		      color[sq] = black;
X		    }
X		}
X	      for (c = 0; c < 8; c++)
X		{
X		  if (*p == qxx[c])
X		    {
X		      board[sq] = c;
X		      color[sq] = white;
X		    }
X		}
X	    }
X	  p++;
X	  Mvboard[sq] = atoi (InPtr);
X	  skip ();
X	}
X    }
X  GameCnt = 0;
X  fgets (fname, 256, fd);
X  fgets (fname, 256, fd);
X  fgets (fname, 256, fd);
X  while (fgets (fname, 256, fd))
X    {
X      struct GameRec *g;
X      int side = computer;
X      side = otherside[side];
X      ++GameCnt;
X      InPtr = fname;
X      skipb ();
X      g = &GameList[GameCnt];
X      g->gmove = parser (InPtr, side);
X      skip ();
X      g->score = atoi (InPtr);
X      skip ();
X      g->depth = atoi (InPtr);
X      skip ();
X      g->nodes = atoi (InPtr);
X      skip ();
X      g->time = atoi (InPtr);
X      skip ();
X      g->flags = c = atoi (InPtr);
X      g->piece = no_piece;
X      g->color = neutral;
X      if (c & (capture | cstlmask))
X	{
X	  if (c & capture)
X	    {
X	      skip ();
X	      for (c = 0; c < 8; c++)
X		if (pxx[c] == *InPtr)
X		  break;
X	      g->piece = c;
X	    }
X	  skip ();
X	  g->color = ((*InPtr == 'B') ? black : white);
X	}
X    }
X  /* GameCnt--;*/
X  if (TimeControl.clock[white] > 0)
X    TCflag = true;
X
X  fclose (fd);
X  ZeroRPT ();
X  InitializeStats ();
X  UpdateDisplay (0, 0, 1, 0);
X  Sdepth = 0;
}
X
X
void
GetXGame (void)
{
X  FILE *fd;
X  char fname[256], *p;
X  int c, i, j;
X  short sq;
X  unsigned short m;
X  fname[0] = 0;
X  ShowMessage ("File name: ");
X  scanz ("%s", fname);
X  if (!fname[0])
X    strcpy (fname, "xboard.position.read");
X  ShowMessage ("Loading ");
X  printz ("%s", fname);
X  if ((fd = fopen (fname, "r")) != NULL)
X    {
X      NewGame ();
X      fgets (fname, 256, fd);
X      fname[6] = '\0';
X      if (strcmp (fname, "xboard"))
X	return;
X      fgets (fname, 256, fd);
X      fgets (fname, 256, fd);
X      for (i = 7; i > -1; i--)
X	{
X	  fgets (fname, 256, fd);
X	  p = fname;
X	  for (j = 0; j < 8; j++)
X	    {
X	      sq = i * 8 + j;
X	      if (*p == '.')
X		{
X		  board[sq] = no_piece;
X		  color[sq] = neutral;
X		}
X	      else
X		{
X		  for (c = 0; c < 8; c++)
X		    {
X		      if (*p == qxx[c])
X			{
X			  board[sq] = c;
X			  color[sq] = black;
X			}
X		    }
X		  for (c = 0; c < 8; c++)
X		    {
X		      if (*p == pxx[c])
X			{
X			  board[sq] = c;
X			  color[sq] = white;
X			}
X		    }
X		}
X	      p += 2;
X	    }
X	}
X      fclose (fd);
X    }
X  ZeroRPT ();
X  InitializeStats ();
X  UpdateDisplay (0, 0, 1, 0);
X  Sdepth = 0;
}
X
void
SaveGame (void)
{
X  FILE *fd;
X  char fname[256], tname[256];
X  short sq, i, c, f, t;
X  char p, *tmp;
X  char *b, *w;
X
X  tname[0] = 0;
X
X  if (tmp = getenv ("HOME"))
X    strcpy (fname, tmp);
X  else
X    fname[0] = '\0';
X  strcat (fname, "/");
X
X  ShowMessage ("File name: ");
X  refresh ();
X  scanz ("%s", tname);
X
X  if (tname[0])
X    strcat (fname, tname);
X  else
X    strcat (fname, "chess.000");
X
X  ShowMessage ("Saving ");
X  printz ("%s", fname);
X
X  if (NULL == (fd = fopen (fname, "w")))
X    {
X      ShowMessage ("Not saved");
X      return;
X    }
X  b = w = "Human";
X  if (computer == black)
X    b = "computer";
X  if (computer == white)
X    w = "computer";
X  fprintf (fd, "Black %s White %s %d\n", b, w, Game50);
X  fprintf (fd, "Castled White %s Black %s\n", castld[white] ? "true" : "false", castld[black] ? "true" : "false");
X  fprintf (fd, "TimeControl %d Operator Time %d\n", TCflag, OperatorTime);
X  fprintf (fd, "White Clock %ld Moves %ld\nBlack Clock %d Moves %d\n\n",
X	   TimeControl.clock[white], TimeControl.moves[white],
X	   TimeControl.clock[black], TimeControl.moves[black]);
X  for (i = 7; i > -1; i--)
X    {
X      fprintf (fd, "%1d ", i + 1);
X      for (c = 0; c < 8; c++)
X	{
X	  sq = i * 8 + c;
X	  switch (color[sq])
X	    {
X	    case black:
X	      p = pxx[board[sq]];
X	      break;
X	    case white:
X	      p = qxx[board[sq]];
X	      break;
X	    default:
X	      p = '.';
X	    }
X	  fprintf (fd, "%c", p);
X	}
X      for (f = i * 8; f < i * 8 + 8; f++)
X	fprintf (fd, " %d", Mvboard[f]);
X      fprintf (fd, "\n");
X    }
X  fprintf (fd, "  %s\n", cxx);
X  fprintf (fd, "\nmove  score depth  nodes  time flags capture color\n");
X  for (i = 1; i <= GameCnt; i++)
X    {
X      struct GameRec *g = &GameList[i];
X      f = g->gmove >> 8;
X      t = (g->gmove & 0xFF);
X      algbr (f, t, g->flags);
X      fprintf (fd, "%s %5d %5d %7ld %5d %5d   %c   %s\n",
X	       mvstr[0], g->score, g->depth,
X	       g->nodes, g->time, g->flags,
X	       pxx[g->piece], g->color == 2 ? "     " : ColorStr[g->color]);
X    }
X  fclose (fd);
X  printz ("Game saved on file: %s", fname);
}
X
void
ListGame (void)
{
X  FILE *fd;
X  char fname[256];
X  char *tmp;
X  short i, f, t;
X
X  if (tmp = getenv ("HOME"))
X    strcpy (fname, tmp);
X  else
X    fname[0] = '\0';
X  strcat (fname, "/chess.lst");
X
X  if (fd = fopen (fname, "w"))
X    ShowMessage ("Writing ~/chess.lst");
X  else
X    {
X      ShowMessage ("Cannot write ~/chess.lst");
X      return;
X    }
X
X  fprintf (fd, "gnuchess\n");
X  fprintf (fd, "       score  depth   nodes  time         ");
X  fprintf (fd, "       score  depth   nodes  time\n");
X  for (i = 1; i <= GameCnt; i++)
X    {
X      f = GameList[i].gmove >> 8;
X      t = (GameList[i].gmove & 0xFF);
X      algbr (f, t, false);
X      if ((i % 2) == 0)
X	fprintf (fd, "\n");
X      else
X	fprintf (fd, "         ");
X      fprintf (fd, "%5s  %5d     %2d %7ld %5d", mvstr[0],
X	       GameList[i].score, GameList[i].depth,
X	       GameList[i].nodes, GameList[i].time);
X    }
X  fprintf (fd, "\n\n");
X  fclose (fd);
X  ShowMessage ("~/chess.lst written");
}
X
void
Undo (void)
X
/*
X  Undo the most recent half-move.
*/
X
{
X  short f, t;
X  f = GameList[GameCnt].gmove >> 8;
X  t = GameList[GameCnt].gmove & 0xFF;
X  if (board[t] == king && distance (t, f) > 1)
X    (void) castle (GameList[GameCnt].color, f, t, 2);
X  else
X    {
X      /* Check for promotion: */
X      if (GameList[GameCnt].flags & promote)
X	{
X	  board[t] = pawn;
X	}
X      board[f] = board[t];
X      color[f] = color[t];
X      board[t] = GameList[GameCnt].piece;
X      color[t] = GameList[GameCnt].color;
X      if (color[t] != neutral)
X	Mvboard[t]--;
X      Mvboard[f]--;
X    }
X  if (GameList[GameCnt].flags & epmask)
X    EnPassant (color[t], f, t, 2);
X  if (TCflag)
X    ++TimeControl.moves[color[f]];
X  GameCnt--;
X  computer = otherside[computer];
X  opponent = otherside[opponent];
X  flag.mate = false;
X  Sdepth = 0;
X  player = otherside[player];
X  ShowSidetoMove ();
X  UpdateDisplay (0, 0, 1, 0);
X  InitializeStats ();
}
X
void
ChangeAlphaWindow (void)
{
X  ShowMessage ("Awindow= ");
X  scanz ("%hd", &Awindow);
}
X
void
ChangeBetaWindow (void)
{
X  ShowMessage ("Bwindow= ");
X  scanz ("%hd", &Bwindow);
}
X
void
GiveHint (void)
{
X  char s[40];
X  algbr ((short) (hint >> 8), (short) (hint & 0xFF), false);
X  strcpy (s, "try ");
X  strcat (s, mvstr[0]);
X  ShowMessage (s);
}
X
void
ChangeHashDepth (void)
{
X  ShowMessage ("hashdepth= ");
X  scanz ("%hd", &HashDepth);
X  ShowMessage ("MoveLimit= ");
X  scanz ("%hd", &HashMoveLimit);
}
X
void
ChangeSearchDepth (void)
{
X  ShowMessage ("depth= ");
X  scanz ("%hd", &MaxSearchDepth);
}
X
void
SetContempt (void)
{
X  ShowMessage ("contempt= ");
X  scanz ("%hd", &contempt);
}
X
X
void
SetAnalysis (void)
{
X  ShowMessage ("game file= ");
X  scanz ("%s", &Analysis);
}
X
void
ChangeXwindow (void)
{
X  ShowMessage ("xwndw= ");
X  scanz ("%hd", &xwndw);
}
X
void
SelectLevel (void)
{
X  ClrScreen ();
X  gotoXY (32, 2);
X  printz ("CHESS");
X  gotoXY (20, 4);
X  printz (" 1.   60 moves in   5 minutes");
X  gotoXY (20, 5);
X  printz (" 2.   60 moves in  15 minutes");
X  gotoXY (20, 6);
X  printz (" 3.   60 moves in  30 minutes");
X  gotoXY (20, 7);
X  printz (" 4.   40 moves in  30 minutes");
X  gotoXY (20, 8);
X  printz (" 5.   40 moves in  60 minutes");
X  gotoXY (20, 9);
X  printz (" 6.   40 moves in 120 minutes");
X  gotoXY (20, 10);
X  printz (" 7.   40 moves in 240 minutes");
X  gotoXY (20, 11);
X  printz (" 8.    1 move  in  15 minutes");
X  gotoXY (20, 12);
X  printz (" 9.    1 move  in  60 minutes");
X  gotoXY (20, 13);
X  printz ("10.    1 move  in 600 minutes");
X
X  OperatorTime = 1;
X  TCmoves = 60;
X  TCminutes = 5;
X
X  gotoXY (20, 17);
X  printz ("Enter Level: ");
X  refresh ();
X  scanz ("%ld", &Level);
X  switch ((int) Level)
X    {
X    case 1:
X      TCmoves = 60;
X      TCminutes = 5;
X      break;
X    case 2:
X      TCmoves = 60;
X      TCminutes = 15;
X      break;
X    case 3:
X      TCmoves = 60;
X      TCminutes = 30;
X      break;
X    case 4:
X      TCmoves = 40;
X      TCminutes = 30;
X      break;
X    case 5:
X      TCmoves = 40;
X      TCminutes = 60;
X      break;
X    case 6:
X      TCmoves = 40;
X      TCminutes = 120;
X      break;
X    case 7:
X      TCmoves = 40;
X      TCminutes = 240;
X      break;
X    case 8:
X      TCmoves = 1;
X      TCminutes = 15;
X      break;
X    case 9:
X      TCmoves = 1;
X      TCminutes = 60;
X      break;
X    case 10:
X      TCmoves = 1;
X      TCminutes = 600;
X      break;
X    }
X
X  TCflag = (TCmoves > 1);
X  SetTimeControl ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
}
X
void
DoDebug (void)
{
X  short c, p, sq, tp, tc, tsq, score;
X  char s[40];
X
X  ExaminePosition ();
X  ShowMessage ("Enter piece: ");
X  scanz ("%s", s);
X  c = neutral;
X  if (s[0] == 'w' || s[0] == 'W')
X    c = white;
X  if (s[0] == 'b' || s[0] == 'B')
X    c = black;
X  for (p = king; p > no_piece; p--)
X    if ((s[1] == pxx[p]) || (s[1] == qxx[p]))
X      break;
X  for (sq = 0; sq < 64; sq++)
X    {
X      tp = board[sq];
X      tc = color[sq];
X      board[sq] = p;
X      color[sq] = c;
X      tsq = PieceList[c][1];
X      PieceList[c][1] = sq;
X      ShowPostnValue (sq);
X      PieceList[c][1] = tsq;
X      board[sq] = tp;
X      color[sq] = tc;
X    }
X  ScorePosition (opponent, &score);
X  ShowScore (score);
}
X
void
TestSpeed (void (*f) (short int side, short int ply))
{
X  short i;
X  long t1, t2;
X
X  t1 = time (0);
X  for (i = 0; i < 10000; i++)
X    {
X      f (opponent, 2);
X    }
X  t2 = time (0);
X  NodeCnt = 10000L * (TrPnt[3] - TrPnt[2]);
X  evrate = NodeCnt / (t2 - t1);
X  ShowNodeCnt (NodeCnt, evrate);
}
X
char s[80];
void
InputCommand (void)
X
/*
X  Process the users command. If easy mode is OFF (the computer is thinking
X  on opponents time) and the program is out of book, then make the 'hint'
X  move on the board and call SelectMove() to find a response. The user
X  terminates the search by entering ^C (quit siqnal) before entering a
X  command. If the opponent does not make the hint move, then set Sdepth to
X  zero.
*/
X
{
X  short ok, tmp;
X  unsigned short mv;
X
X  ok = flag.quit = false;
X  player = opponent;
X  ShowSidetoMove ();
X  ft = 0;
X  if (hint > 0 && !flag.easy && Book == NULL)
X    {
X      fflush (stdout);
X      time0 = time ((long *) 0);
X      algbr ((short) hint >> 8, (short) hint & 0xFF, false);
X      strcpy (s, mvstr[0]);
X      tmp = epsquare;
X      if (VerifyMove (s, 1, &mv))
X	{
X	  ShowPrompt ();
X	  SelectMove (computer, 2);
X	  (void) VerifyMove (mvstr[0], 2, &mv);
X	  if (Sdepth > 0)
X	    Sdepth--;
X	}
X      ft = time ((long *) 0) - time0;
X      epsquare = tmp;
X    }
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
#endif /* MSDOS */
X  while (!(ok || flag.quit))
X    {
X      ShowPrompt ();
X      scanz ("%s", s);
X      player = opponent;
X      ok = VerifyMove (s, 0, &mv);
X      if (ok && mv != hint)
X	{
X	  Sdepth = 0;
X	  ft = 0;
X	}
X      if (*s == '\0')
X	UpdateDisplay (0, 0, 1, 0);
X      else if (strcmp (s, "bd") == 0)
X	{
X	  ClrScreen ();
X	  UpdateDisplay (0, 0, 1, 0);
X	}
X      else if ((strcmp (s, "quit") == 0) || (strcmp (s, "exit") == 0))
X	flag.quit = true;
X      else if (strcmp (s, "post") == 0)
X	flag.post = !flag.post;
X      else if (strcmp (s, "edit") == 0)
X	EditBoard ();
X      else if (strcmp (s, "go") == 0)
X	ok = true;
X      else if (strcmp (s, "help") == 0)
X	help ();
X      else if (strcmp (s, "force") == 0)
X	flag.force = !flag.force;
X      else if (strcmp (s, "book") == 0)
X	Book = NULL;
X      else if (strcmp (s, "undo") == 0 && GameCnt > 0)
X	Undo ();
X      else if (strcmp (s, "new") == 0)
X	NewGame ();
X      else if (strcmp (s, "list") == 0)
X	ListGame ();
X      else if (strcmp (s, "level") == 0)
X	SelectLevel ();
X      else if (strcmp (s, "hash") == 0)
X	flag.hash = !flag.hash;
X      else if (strcmp (s, "beep") == 0)
X	flag.beep = !flag.beep;
X      else if (strcmp (s, "Awindow") == 0)
X	ChangeAlphaWindow ();
X      else if (strcmp (s, "Bwindow") == 0)
X	ChangeBetaWindow ();
X      else if (strcmp (s, "hint") == 0)
X	GiveHint ();
X      else if (strcmp (s, "both") == 0)
X	{
X	  flag.bothsides = !flag.bothsides;
X	  Sdepth = 0;
X	  SelectMove (opponent, 1);
X	  ok = true;
X	}
X      else if (strcmp (s, "reverse") == 0)
X	{
X	  flag.reverse = !flag.reverse;
X	  ClrScreen ();
X	  UpdateDisplay (0, 0, 1, 0);
X	}
#if !defined(MSDOS) || defined(SEVENBIT)
X      else if (strcmp (s, "shade") == 0)
X	{
X	  shade = !shade;
X	  ClrScreen ();
X	  UpdateDisplay (0, 0, 1, 0);
X	}
#endif /* MSDOS && !SEVENBIT */
X      else if (strcmp (s, "switch") == 0)
X	{
X	  computer = otherside[computer];
X	  opponent = otherside[opponent];
X	  flag.force = false;
X	  Sdepth = 0;
X	  ok = true;
X	}
X      else if (strcmp (s, "white") == 0)
X	{
X	  computer = white;
X	  opponent = black;
X	  flag.force = false;
X	  Sdepth = 0;
X	  /*ok = true;/* don't start automatically on white command */
X	}
X      else if (strcmp (s, "black") == 0)
X	{
X	  computer = black;
X	  opponent = white;
X	  flag.force = false;
X	  Sdepth = 0;
X	  /*ok = true;/* don't start automatically on black command */
X	}
X      else if (strcmp (s, "remove") == 0 && GameCnt > 1)
X	{
X	  Undo ();
X	  Undo ();
X	}
X      else if (strcmp (s, "get") == 0)
X	GetGame ();
X      else if (strcmp (s, "xget") == 0)
X	GetXGame ();
X      else if (strcmp (s, "save") == 0)
X	SaveGame ();
X      else if (strcmp (s, "depth") == 0)
X	ChangeSearchDepth ();
X      else if (strcmp (s, "hashdepth") == 0)
X	ChangeHashDepth ();
X      else if (strcmp (s, "random") == 0)
X	dither = 6;
X      else if (strcmp (s, "easy") == 0)
X	flag.easy = !flag.easy;
X      else if (strcmp (s, "contempt") == 0)
X	SetContempt ();
X      else if (strcmp (s, "analysis") == 0)
X	SetAnalysis ();
X      else if (strcmp (s, "xwndw") == 0)
X	ChangeXwindow ();
X      else if (strcmp (s, "coords") == 0)
X	{
X	  coords = !coords;
X	  UpdateDisplay (0, 0, 1, 0);
X	}
#if !defined(MSDOS) || defined(SEVENBIT)
X      else if (strcmp (s, "stars") == 0)
X	{
X	  stars = !stars;
X	  UpdateDisplay (0, 0, 1, 0);
X	}
#endif /* MSDOS && !SEVENBIT */
X      else if (strcmp (s, "test") == 0)
X	{
X	  ShowMessage ("Testing MoveList Speed");
X	  TestSpeed (MoveList);
X	  ShowMessage ("Testing CaptureList Speed");
X	  TestSpeed (CaptureList);
X	}
X      else if (strcmp (s, "p") == 0)
X	ShowPostnValues ();
X      else if (strcmp (s, "debug") == 0)
X	DoDebug ();
X      else if (strcmp (s, "rv") == 0)
X	{
X	  rv = !rv;
#if !defined(MSDOS) || defined(SEVENBIT)
X	  shade = !rv;
X	  stars = !rv;
#endif /* MSDOS && !SEVENBIT */
X	  UpdateDisplay (0, 0, 1, 0);
X	}
X    }
X
X  ClearMessage ();
X  ElapsedTime (1);
X  if (flag.force)
X    {
X      computer = opponent;
X      opponent = otherside[computer];
X    }
X  signal (SIGINT, TerminateSearch);
#ifndef MSDOS
X  signal (SIGQUIT, TerminateSearch);
#endif /* MSDOS */
}
SHAR_EOF
echo 'File nuxdsp.c is complete' &&
chmod 0664 nuxdsp.c ||
echo 'restore of nuxdsp.c failed'
Wc_c="`wc -c < 'nuxdsp.c'`"
test 38643 -eq "$Wc_c" ||
	echo 'nuxdsp.c: original size 38643, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= postprint.c ==============
if test -f 'postprint.c' -a X"$1" != X"-c"; then
	echo 'x - skipping postprint.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting postprint.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'postprint.c' &&
#include <stdio.h>
#include "gnuchess.h"
#define HASHFILE "/usr/local/lib/gnuchess.hash"
#ifdef MSDOS
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define RWA_ACC "r+b"
#define WA_ACC "w+b"
#else
#define RWA_ACC "r+"
#define WA_ACC "w+"
#include <sys/param.h>
#include <sys/types.h>
#include <sys/times.h>
#endif /* MSDOS */
FILE *hashfile;
#define rxx "12345678"
#define cxx "abcdefgh"
#define pxx "1PNBRQK"
#define qxx "1pnbrqk"
#define truescore 0x0001
#define lowerbound 0x0002
#define upperbound 0x0004
#define kingcastle 0x0008
#define queencastle 0x0010
X
struct fileentry
{
X  unsigned char bd[32];
X  unsigned char f, t, flags, depth, sh, sl;
};
long i, j;
int nr[maxdepth];
struct fileentry n;
int r, c;
char line[128];
char *l;
short int t;
int c1, c2;
char mvstr[3][6];
short int board[64];
void
algbr (short int f, short int t, short int flag)
/*
X * Generate move strings in different formats.
X */
X
{
X  int m3p;
X
X  if (f != t)
X    {
X      /* algebraic notation */
X      mvstr[0][0] = cxx[column (f)];
X      mvstr[0][1] = rxx[row (f)];
X      mvstr[0][2] = cxx[column (t)];
X      mvstr[0][3] = rxx[row (t)];
X      mvstr[0][4] = mvstr[3][0] = '\0';
X      if (((mvstr[1][0] = pxx[board[f]]) == 'P') || (flag & promote))
X	{
X	  if (mvstr[0][0] == mvstr[0][2])
X	    {			       /* pawn did not eat */
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][2];	/* to column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][3];	/* to row */
X	      m3p = 2;
X	    }
X	  else
X	    /* pawn ate */
X	    {
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][0];	/* from column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][2];	/* to column */
X	      mvstr[2][2] = mvstr[0][3];
X	      m3p = 3;		       /* to row */
X	    }
X	  mvstr[2][m3p] = mvstr[1][2] = '\0';
X	  if (flag & promote)
X	    {
X	      mvstr[0][4] = mvstr[1][2] = mvstr[2][m3p] = qxx[flag & pmask];
X	      mvstr[1][3] = mvstr[2][m3p + 1] = mvstr[0][5] = '\0';
X	    }
X	}
X      else
X	/* not a pawn */
X	{
X	  mvstr[2][0] = mvstr[1][0];
X	  mvstr[2][1] = mvstr[0][1];
X	  mvstr[2][2] = mvstr[1][1] = mvstr[0][2];	/* to column */
X	  mvstr[2][3] = mvstr[1][2] = mvstr[0][3];	/* to row */
X	  mvstr[2][4] = mvstr[1][3] = '\0';
X	  strcpy (mvstr[3], mvstr[2]);
X	  mvstr[3][1] = mvstr[0][0];
X	  if (flag & cstlmask)
X	    {
X	      if (t > f)
X		{
X		  strcpy (mvstr[1], "o-o");
X		  strcpy (mvstr[2], "O-O");
X		}
X	      else
X		{
X		  strcpy (mvstr[1], "o-o-o");
X		  strcpy (mvstr[2], "O-O-O");
X		}
X	    }
X	}
X    }
X  else
X    mvstr[0][0] = mvstr[1][0] = mvstr[2][0] = mvstr[3][0] = '\0';
}
X
int
main (int argc, char **argv)
{
X  int f = 0;
X  char flbuf[10];
X  char *fl;
X  if ((hashfile = fopen (HASHFILE, RWA_ACC)) == NULL)
X    exit (1);
X  for (i = 0; i < maxdepth; i++)
X    nr[i] = 0;
X  fseek (hashfile, 0L, SEEK_END);
X  i = ftell (hashfile) / sizeof (struct fileentry);
X  fseek (hashfile, 0L, SEEK_SET);
X  printf ("/V 11 72 mul def /L 60 def\n");
X  for (j = 0; j < i; j++)
X    {
X      fread (&n, sizeof (struct fileentry), 1, hashfile);
X      if (n.depth)
X	{
X	  nr[0]++;
X	  if (nr[0] == 19)
X	    {
X	      nr[0] = 1;
X	      printf ("showpage\n/V 11 72 mul def\n");
X	      printf ("/L 60 def\n");
X	      f = 0;
X	    }
X	  /* now process this entry */
X	  strcpy (line, "C ('#[");
X	  for (r = 0; r < 8; r++)
X	    {
X	      l = line + 6 + (7 - r) * 9;
X	      for (c = 0; c < 4; c++)
X		{
X		  c1 = (n.bd[r * 4 + c] >> 4) & 0xf;
X		  c2 = n.bd[r * 4 + c] & 0xf;
X		  board[r * 8 + c * 2] = (int) c1 & 0x7;
X		  board[r * 8 + c * 2 + 1] = (int) c2 & 0x7;
X		  if (c1 & 0x8)
X		    *l++ = qxx[c1 & 0x7];
X		  else
X		    *l++ = pxx[c1 & 0x7];
X		  if (c2 & 0x8)
X		    *l++ = qxx[c2 & 0x7];
X		  else
X		    *l++ = pxx[c2 & 0x7];
X		}
X	      *l++ = ';';
X	    }
X	  l--;
X	  line[79] = '\0';
X	  strcat (line, "]') show");
X	  algbr (n.f, n.t, 0);
X	  t = (n.sh << 8) + n.sl;
X	  /* decode flags */
X	  fl = flbuf;
X	  if (n.flags & kingcastle)
X	    *fl++ = 'k';
X	  if (n.flags & queencastle)
X	    *fl++ = 'q';
X	  if (n.flags & truescore)
X	    *fl++ = 't';
X	  if (n.flags & lowerbound)
X	    *fl++ = 'l';
X	  if (n.flags & upperbound)
X	    *fl++ = 'u';
X	  *fl = '\0';
X	  printf ("L V moveto\n");
X	  printf ("R (%s flags %s depth %d score %d", mvstr[0], flbuf, n.depth, t);
X	  printf (") show\n");
X	  printf ("L  V 100 sub moveto\n");
X	  printf ("%s\n", line);
X	  f++;
X	  if (f == 3)
X	    {
X	      printf ("/V V 120 sub def /L 60 def\n");
X	      f = 0;
X	    }
X	  else
X	    printf ("/L 160 L add def\n");
X	}
X    }
X  if (nr[0])
X    printf ("showpage\n");
}
SHAR_EOF
chmod 0664 postprint.c ||
echo 'restore of postprint.c failed'
Wc_c="`wc -c < 'postprint.c'`"
test 4447 -eq "$Wc_c" ||
	echo 'postprint.c: original size 4447, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= uxdsp.c ==============
if test -f 'uxdsp.c' -a X"$1" != X"-c"; then
	echo 'x - skipping uxdsp.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting uxdsp.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'uxdsp.c' &&
/* uxdsp.c - ALPHA interface for CHESS
X
X  Revision: 1991-04-15
X
X  Copyright (C) 1986, 1987, 1988, 1989, 1990 Free Software Foundation, Inc.
X  Copyright (c) 1988, 1989, 1990  John Stanback
X
X  This file is part of CHESS.
X
X  CHESS is distributed in the hope that it will be useful, but WITHOUT ANY
X  WARRANTY.  No author or distributor accepts responsibility to anyone for
X  the consequences of using it or for whether it serves any particular
X  purpose or works at all, unless he says so in writing.  Refer to the CHESS
X  General Public License for full details.
X
X  Everyone is granted permission to copy, modify and redistribute CHESS, but
X  only under the conditions described in the CHESS General Public License.
X  A copy of this license is supposed to have been given to you along with
X  CHESS so you can know your rights and responsibilities.  It should be in a
X  file named COPYING.  Among other things, the copyright notice and this
X  notice must be preserved on all copies.
*/
X
#include <ctype.h>
#include <signal.h>
#ifdef MSDOS
#include <dos.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
X
#define ESC 0x1B
#define scanz scanf
#define printz printf
#define refresh() fflush(stdout)
X
int mycntl1, mycntl2;
static void param (short n);
#else
#include <sys/param.h>
#include <sys/types.h>
#include <sys/file.h>
#include <curses.h>
X
#define scanz fflush(stdout),scanw
#define printz printw
X
/* <stdlib.h> */
extern void *malloc (size_t);
extern void exit (int);
/* <string.h> */
extern char *strcat (char *, const char *);
extern int strcmp (const char *, const char *);
extern char *strcpy (char *, const char *);
/* <time.h> */
extern long int time (long int *);
#endif /* MSDOS */
X
#include "gnuchess.h"
X
#define pxx " PNBRQK"
#define qxx " pnbrqk"
#define rxx "12345678"
#define cxx "abcdefgh"
#define TAB (46)
#define VIR_C(s)  ((flag.reverse) ? 7-column(s) : column(s))
#define VIR_R(s)  ((flag.reverse) ? 7-row(s) : row(s))
X
char Analysis[128] = "";
short int MV[maxdepth];
int MSCORE;
char *DRAW;
char mvstr[4][6];
static char *ColorStr[2] =
{"White", "Black"};
static long evrate;
X
extern char *getenv (const char *);
void TerminateSearch (int), Die (int);
X
void
Initialize (void)
{
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
X  initscr ();
X  crmode ();
#else
X  mycntl1 = mycntl2 = 0;
#endif /* MSDOS */
}
X
void
ExitChess (void)
{
X  ListGame ();
X  gotoXY (1, 24);
#ifndef MSDOS
X  nocrmode ();
X  endwin ();
#endif /* MSDOS */
X  exit (0);
}
X
void
Die (int Sig)
{
X  char s[80];
X
X  signal (SIGINT, SIG_IGN);
#ifdef MSDOS
X  Sig++;			       /* shut up the compiler */
#else
X  signal (SIGQUIT, SIG_IGN);
#endif /* MSDOS */
X  ShowMessage ("Abort? ");
X  scanz ("%s", s);
X  if (strcmp (s, "yes") == 0)
X    ExitChess ();
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
#endif /* MSDOS */
}
X
void
TerminateSearch (int Sig)
{
X  signal (SIGINT, SIG_IGN);
#ifdef MSDOS
X  Sig++;			       /* shut up the compiler */
#else
X  signal (SIGQUIT, SIG_IGN);
#endif /* MSDOS */
X  flag.timeout = true;
X  flag.bothsides = false;
X  signal (SIGINT, Die);
#ifndef MSDOS
X  signal (SIGQUIT, Die);
#endif /* MSDOS */
}
void 
ShowLine (short unsigned int *bstline)
{
}
X
void
algbr (short int f, short int t, short int flag)
X
/*
X   Generate move strings in different formats.
*/
X
{
X  int m3p;
X
X  if (f != t)
X    {
X      /* algebraic notation */
X      mvstr[0][0] = cxx[column (f)];
X      mvstr[0][1] = rxx[row (f)];
X      mvstr[0][2] = cxx[column (t)];
X      mvstr[0][3] = rxx[row (t)];
X      mvstr[0][4] = mvstr[3][0] = '\0';
X      if (((mvstr[1][0] = pxx[board[f]]) == 'P') || (flag & promote))
X	{
X	  if (mvstr[0][0] == mvstr[0][2])	/* pawn did not eat */
X	    {
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][2];	/* to column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][3];	/* to row */
X	      m3p = 2;
X	    }
X	  else
X	    /* pawn ate */
X	    {
X	      mvstr[2][0] = mvstr[1][0] = mvstr[0][0];	/* from column */
X	      mvstr[2][1] = mvstr[1][1] = mvstr[0][2];	/* to column */
X	      mvstr[2][2] = mvstr[0][3];
X	      m3p = 3;		       /* to row */
X	    }
X	  mvstr[2][m3p] = mvstr[1][2] = '\0';
X	  if (flag & promote)
X	    {
X	      mvstr[0][4] = mvstr[1][2] = mvstr[2][m3p] = qxx[flag & pmask];
X	      mvstr[1][3] = mvstr[2][m3p + 1] = mvstr[0][5] = '\0';
X	    }
X	}
X      else
X	/* not a pawn */
X	{
X	  mvstr[2][0] = mvstr[1][0];
X	  mvstr[2][1] = mvstr[0][1];
SHAR_EOF
true || echo 'restore of uxdsp.c failed'
fi
echo 'End of  part 6'
echo 'File uxdsp.c is continued in part 7'
echo 7 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
-- 
Kent Landfield                   INTERNET: kent@sparky.IMD.Sterling.COM
Sterling Software, IMD           UUCP:     uunet!sparky!kent
Phone:    (402) 291-8300         FAX:      (402) 291-4362
Please send comp.sources.misc-related mail to kent@uunet.uu.net.


