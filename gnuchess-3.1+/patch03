From pa.dec.com!decwrl!uunet!sparky!kent Sun Aug 18 09:18:07 PDT 1991
Article: 2623 of comp.sources.misc
Newsgroups: comp.sources.misc
Path: pa.dec.com!decwrl!uunet!sparky!kent
From: Mike McGann <mwm@hasler.ascom.ch>
Subject:  v22i002:  gnuchess - gnuchess version 3.1+, Patch03
Message-ID: <1991Aug13.043250.24690@sparky.IMD.Sterling.COM>
X-Md4-Signature: c8b4fabf55f6def1ab97624c30b20e62
Sender: kent@sparky.IMD.Sterling.COM (Kent Landfield)
Organization: Sterling Software, IMD
Date: Tue, 13 Aug 1991 04:32:50 GMT
Approved: kent@sparky.imd.sterling.com
Lines: 609

Submitted-by: Mike McGann <mwm@hasler.ascom.ch>
Posting-number: Volume 22, Issue 2
Archive-name: gnuchess/patch03
Environment: UNIX, DOS
Patch-To: gnuchess: Volume 19, Issue 73-79

Enclosed is patch3 for gnuchess3.1+. It is mainly improvements to handling
the opening book. These came from Philippe Schnoebelen  phs@lifia.imag.fr.
I have checked them out and they seem to function fine. The diffs are against
gnuchess3.1+ patchlevel 2.

mike
---
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	README.patch3
#	patch3
# This archive created: Mon Aug 12 13:06:48 1991
export PATH; PATH=/bin:$PATH
if test -f 'README.patch3'
then
	echo shar: will not over-write existing file "'README.patch3'"
else
cat << \SHAR_EOF > 'README.patch3'
This is patch3 for gnuchess3.1+, It contains a set of improvements
and fixes mainly in handling the opening book. They came from
 phs@lifia.imag.fr (Philippe Schnoebelen). Phillipe sent me the 
following note about the changes.

Mike McGann
mwm@hslrswi.hasler.ascom.ch

---
I've made some more minor modifications because:

1) if you edit the board and use more than 16 men, gnuchess is lost,

2) if you quit the opening book and then backtrack, gnuchess has lost the
book, 

3) if you edit the board, gnuchess still use its book !

In addition, I allowed the '?' to be used in the opening book. A move
tagged with '?' is not played by gnuchess. This allows teaching the program
how to refute unsound traps, without letting it playing them.

Here is the patch. Do you know if anybody is coordinating the GnuChess
development project ?

--Philippe
SHAR_EOF
fi # end of overwriting check
if test -f 'patch3'
then
	echo shar: will not over-write existing file "'patch3'"
else
cat << \SHAR_EOF > 'patch3'
*** 1.1	1991/08/12 10:41:10
--- ChangeLog	1991/08/12 10:50:22
***************
*** 1,4 ****
--- 1,31 ----
+ Tue Aug  6 18:10:47 1991  Philippe Schnoebelen  (phs@lifia.imag.fr)
+ 
+ 	* Modify handling of Book in Undo (previously, when you
+ 	backtracked after quitting the book, the program was not able to
+ 	use it again)
+ 
+ 	* Modify handling of Book in EditBoard and other routines so that
+ 	the Book is not used if you don't start from the regular initial board.
+ 
+ Mon Aug  5 17:26:59 1991  Philippe Schnoebelen  (phs@lifia.imag.fr)
+ 
+ 	* Modify parse in gnuchess.c so that a move can be followed by '?'
+ 	indicating that the program should not play it itself. Such a move
+ 	is stored with the highest bit raised.
+           Modify OpeningBook in gnuchess.c so that moves with highest bit
+ 	set are recognized but not played by the program.
+ 
+ 	* Modify the declaration of array PieceList in gnuchess.[ch] to
+ 	allow for up to 64 men of the same side. Such artificial
+ 	situations can be built with edit and the program must be able to
+ 	deal with them.
+ 
+ Mon Aug 1 10:20 1991 Mike McGann {mwm@hslrswi.hasler.ascom.ch)
+ 	Split chesstool and xboard versions. Xboard is now
+ 	gnuchessx and chesstool is gnuchessc.
+ 
  Mon Apr 15 10:20 1991 Mike McGann {mwm@hslrswi.hasler.ascom.ch)
+ 	Changed transposition table to cache positions found in transposition file
  	Fix Undo's incorrect handling of promotions.
  	Fix win and draw determination bugs.
   	Fix bug in algbr that prevented correct display of promotion moves.
*** 1.2	1991/08/12 10:43:46
--- Makefile	1991/08/12 10:50:22
***************
*** 75,83 ****
  postprint: postprint.o
  	$(CC) $(CFLAGS) -o postprint postprint.o
  	
! gnuchessd: gnuchess.c nuxdsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -DDEBUG -o  gnuchessd  nondsp.c gnuchess.c
! 	rm nondsp.o gnuchess.o
  
  gnuan.o: gnuan.c gnuchess.h version.h
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c gnuan.c
--- 75,83 ----
  postprint: postprint.o
  	$(CC) $(CFLAGS) -o postprint postprint.o
  	
! gnuchessd:  nondsp.c gnuchess.c
! 	$(CC) -Wall -fstrength-reduce -p -g -Dinline="" $(HASH) $(BOOK) -DCHESSTOOL -DDEBUG -o  gnuchessd  nondsp.c gnuchess.c
! 
  
  gnuan.o: gnuan.c gnuchess.h version.h
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c gnuan.c
*** 1.1	1991/08/12 10:41:10
--- gnuan.c	1991/08/12 10:50:23
***************
*** 516,521 ****
--- 516,523 ----
    flag.mate = false;
    Sdepth = 0;
    InitializeStats ();
+   if (flag.regularstart)
+     Book = BKBook;
  }
  
  void
*** 1.1	1991/08/12 10:41:10
--- gnuchess.book	1991/08/12 10:50:23
***************
*** 3901,3903 ****
--- 3901,3951 ----
  d1e2  f6e4
  a1c1  a8c8
  !
+ ! Sicilian - Morra Gambit (declined)
+ e2e4  c7c5
+ d2d4? c5d4
+ c2c3  d4d3
+ !
+ e2e4  c7c5
+ d2d4? c5d4
+ g1f3  e7e6
+ !
+ ! Alekhine's Defence
+ e2e4  g8f6
+ f1c4  f6e4?
+ c4f7  e8f7
+ d1h5  f7e6
+ h5g4  e6d5
+ c2c4
+ !
+ e2e4  g8f6
+ f1c4  e7e5
+ !
+ ! Damiano defence (how to refute it)
+ e2e4 e7e5
+ g1f3 f7f6?
+ f3e5 f6e5
+ d1h5 e8e7
+ h5e5 e7f7
+ f1c4
+ !
+ ! Two Knights Defence
+ e2e4  e7e5
+ g1f3  b8c6
+ f1c4  g8f6
+ f3g5  d7d5
+ e4d5  f6d5?
+ g5f7  e8f7
+ d1f3  f7e6
+ b1c3
+ !
+ ! Hungarian Defence
+ e2e4  e7e5
+ g1f3  b8c6
+ f1c4  f8e7?
+ d2d4  e5d4
+ c2c3  d4c3
+ d1d5  g8h6
+ c1h6  e8g8
+ h6g7
+ !
*** 1.1	1991/08/12 10:41:10
--- gnuchess.c	1991/08/12 10:50:24
***************
*** 145,151 ****
  char listfile[128] = "";
  struct leaf Tree[2000], *root;
  short TrPnt[maxdepth];
! short PieceList[2][16], PawnCnt[2][8];
  #define wking PieceList[white][0]
  #define bking PieceList[black][0]
  #define EnemyKing PieceList[c2][0]
--- 145,151 ----
  char listfile[128] = "";
  struct leaf Tree[2000], *root;
  short TrPnt[maxdepth];
! short PieceList[2][64], PawnCnt[2][8];
  #define wking PieceList[white][0]
  #define bking PieceList[black][0]
  #define EnemyKing PieceList[c2][0]
***************
*** 320,330 ****
  const short Stcolor[64] =
  {white, white, white, white, white, white, white, white,
   white, white, white, white, white, white, white, white,
!  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
!  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
   black, black, black, black, black, black, black, black,
   black, black, black, black, black, black, black, black};
  short board[64], color[64];
  static unsigned char nextpos[8][64][64];
  static unsigned char nextdir[8][64][64];
  /*
--- 320,346 ----
  const short Stcolor[64] =
  {white, white, white, white, white, white, white, white,
   white, white, white, white, white, white, white, white,
!  neutral, neutral, neutral, neutral, neutral, neutral, neutral, neutral,
!  neutral, neutral, neutral, neutral, neutral, neutral, neutral, neutral,
!  neutral, neutral, neutral, neutral, neutral, neutral, neutral, neutral,
!  neutral, neutral, neutral, neutral, neutral, neutral, neutral, neutral,
   black, black, black, black, black, black, black, black,
   black, black, black, black, black, black, black, black};
  short board[64], color[64];
+ /* nextpos[piece][from-square] , nextdir[piece][from-square] gives vector of positions reachable from from-square 
+ 	in ppos with piece such that the sequence	
+ 			ppos = nextpos[piece][from-square];
+ 			pdir = nextdir[piece][from-square];
+ 			u = ppos[sq];
+ 			do {
+ 				u = ppos[u];
+ 				if(color[u] != neutral) u = pdir[u];
+ 			} while (sq != u);
+ 	will generate the sequence of all squares reachable from sq.
+ 
+ 	If the path is blocked u = pdir[sq] will generate the continuation of the sequence in other directions.
+ */
+ 	
  static unsigned char nextpos[8][64][64];
  static unsigned char nextdir[8][64][64];
  /*
***************
*** 337,342 ****
--- 353,359 ----
  {
    no_piece, pawn, knight, bishop, rook, queen, king, no_piece,
    no_piece, bpawn, knight, bishop, rook, queen, king, no_piece};
+ /* data used to generate nextpos/nextdir */
  static const short direc[8][8] =
  {
    0, 0, 0, 0, 0, 0, 0, 0,
***************
*** 691,696 ****
--- 708,714 ----
    time0 = time ((long *) 0);
    ElapsedTime (1);
    UpdateDisplay (0, 0, 1, 0);
+   flag.regularstart = true;
    Book = BKBook;
  }
  
***************
*** 800,806 ****
  
        for (i = TrPnt[1]; i < TrPnt[2]; i++)
  	pick (i, TrPnt[2] - 1);
!       if (Book != NULL)
  	OpeningBook (&hint);
        if (Book != NULL)
  	flag.timeout = true;
--- 818,824 ----
  
        for (i = TrPnt[1]; i < TrPnt[2]; i++)
  	pick (i, TrPnt[2] - 1);
!       if (flag.regularstart && Book != NULL)
  	OpeningBook (&hint);
        if (Book != NULL)
  	flag.timeout = true;
***************
*** 862,868 ****
    if (rpt >= 2)
      {
        root->flags |= draw;
!       DRAW = "Repitition";
      }
    if (score < -12000)
      {
--- 880,886 ----
    if (rpt >= 2)
      {
        root->flags |= draw;
!       DRAW = "Repetition";
      }
    if (score < -12000)
      {
***************
*** 931,937 ****
    while ((c = getc (fd)) == ' ') ;
    i = 0;
    s[0] = (char) c;
!   while (c != ' ' && c != '\n' && c != EOF)
      s[++i] = (char) (c = getc (fd));
    s[++i] = '\0';
    if (c == EOF)
--- 949,955 ----
    while ((c = getc (fd)) == ' ') ;
    i = 0;
    s[0] = (char) c;
!   while (c != '?' && c != ' ' && c != '\t' && c != '\n' && c != EOF)
      s[++i] = (char) (c = getc (fd));
    s[++i] = '\0';
    if (c == EOF)
***************
*** 954,959 ****
--- 972,981 ----
        r2 = s[3] - '1';
        *mv = (locn (r1, c1) << 8) | locn (r2, c2);
      }
+   if (c == '?') {		/* Bad move, not for the program to play */
+     *mv |= 0x8000;		/* Flag it ! */
+     c = getc(fd);
+  }
    return (1);
  }
  
***************
*** 965,971 ****
     into an unsigned integer format indicating the from and to square. Create
     a linked list of opening lines of play, with entry->next pointing to the
     next line and entry->move pointing to a chunk of memory containing the
!    moves. More Opening lines of up to 256 half moves may be added to
     gnuchess.book.
  */
  #ifndef BOOK
--- 987,993 ----
     into an unsigned integer format indicating the from and to square. Create
     a linked list of opening lines of play, with entry->next pointing to the
     next line and entry->move pointing to a chunk of memory containing the
!    moves. More Opening lines of up to 100 half moves may be added to
     gnuchess.book.
  */
  #ifndef BOOK
***************
*** 1036,1042 ****
    unsigned short m, *mp;
    unsigned r, r0;
    struct BookEntry *p;
! 
    srand ((unsigned int) time ((long *) 0));
    r0 = m = 0;
    p = Book;
--- 1058,1064 ----
    unsigned short m, *mp;
    unsigned r, r0;
    struct BookEntry *p;
!   
    srand ((unsigned int) time ((long *) 0));
    r0 = m = 0;
    p = Book;
***************
*** 1044,1057 ****
      {
        mp = p->mv;
        for (j = 1; j <= GameCnt; j++)
! 	if (GameList[j].gmove != *(mp++))
  	  break;
!       if (j > GameCnt)
  	if ((r = urand ()) > r0)
  	  {
  	    r0 = r;
! 	    m = *mp;
! 	    *hint = *(++mp);
  	  }
        p = p->next;
      }
--- 1066,1080 ----
      {
        mp = p->mv;
        for (j = 1; j <= GameCnt; j++)
! 	if ( GameList[j].gmove != (*(mp++) & 0x7FFF) ) {
  	  break;
!        }
!       if ( (j > GameCnt) && ((*mp & 0x8000) == 0) )
  	if ((r = urand ()) > r0)
  	  {
  	    r0 = r;
! 	    m = (*mp & 0x7FFF);
! 	    *hint = (*(++mp) & 0x7FFF);
  	  }
        p = p->next;
      }
*** 1.1	1991/08/12 10:41:10
--- gnuchess.h	1991/08/12 10:50:24
***************
*** 109,114 ****
--- 109,115 ----
    short mate;		/* the game is over */
    short post;		/* show principle variation */
    short quit;		/* quit/exit gnuchess */
+   short regularstart;	/* did the game start from standard initial board ? */
    short reverse;	/* reverse board display */
    short bothsides;	/* computer plays both sides */
    short hash;		/* enable/disable transposition table */
***************
*** 123,129 ****
  extern char savefile[128], listfile[128];
  extern short TrPnt[maxdepth];
  extern short board[64], color[64];
! extern short PieceList[2][16], PawnCnt[2][8];
  extern short castld[2], Mvboard[64];
  extern short svalue[64];
  extern struct flags flag;
--- 124,130 ----
  extern char savefile[128], listfile[128];
  extern short TrPnt[maxdepth];
  extern short board[64], color[64];
! extern short PieceList[2][64], PawnCnt[2][8];
  extern short castld[2], Mvboard[64];
  extern short svalue[64];
  extern struct flags flag;
***************
*** 136,142 ****
  extern struct GameRec GameList[200];
  extern short GameCnt, Game50;
  extern short Sdepth, MaxSearchDepth;
! extern struct BookEntry *Book;
  extern struct TimeControlRec TimeControl;
  extern short TCflag, TCmoves, TCminutes, OperatorTime;
  extern const short otherside[3];
--- 137,143 ----
  extern struct GameRec GameList[200];
  extern short GameCnt, Game50;
  extern short Sdepth, MaxSearchDepth;
! extern struct BookEntry *Book, *BKBook;
  extern struct TimeControlRec TimeControl;
  extern short TCflag, TCmoves, TCminutes, OperatorTime;
  extern const short otherside[3];
*** 1.3	1991/08/12 10:43:46
--- nondsp.c	1991/08/12 10:50:24
***************
*** 148,153 ****
--- 148,160 ----
  	    {
  	      mvstr[0][4] = mvstr[1][2] = mvstr[2][m3p] = qxx[flag & pmask];
  	      mvstr[1][3] = mvstr[2][m3p + 1] = mvstr[0][5] = '\0';
+ #ifdef CHESSTOOL
+ 	      mvstr[3][0] = mvstr[0][0]; /* Allow e7e8 for chesstool */
+ 	      mvstr[3][1] = mvstr[0][1];
+ 	      mvstr[3][2] = mvstr[0][2];
+ 	      mvstr[3][3] = mvstr[0][3];
+ 	      mvstr[3][4] = '\0';
+ #endif
  	    }
  	  mvstr[2][m3p] = mvstr[1][2] = '\0';
  	}
***************
*** 340,345 ****
--- 347,354 ----
    short a, r, c, sq, i;
    char s[80];
  
+   flag.regularstart = false;
+   Book = NULL;
    ClrScreen ();
    UpdateDisplay (0, 0, 1, 0);
    printz (".   exit to main\n");
***************
*** 802,807 ****
--- 811,818 ----
  	    }
  	}
        GameCnt = 0;
+       flag.regularstart = false;
+       Book = NULL;
        fgets (fname, 256, fd);
        fgets (fname, 256, fd);
        fgets (fname, 256, fd);
***************
*** 863,868 ****
--- 874,881 ----
    if ((fd = fopen (fname, "r")) != NULL)
      {
        NewGame ();
+       flag.regularstart = false;
+       Book = NULL;
        fgets (fname, 256, fd);
        fname[6] = '\0';
        if (strcmp (fname, "xboard"))
***************
*** 1057,1062 ****
--- 1070,1077 ----
    ShowSidetoMove();
    UpdateDisplay (0, 0, 1, 0);
    InitializeStats ();
+   if (flag.regularstart)
+     Book = BKBook;
  }
  
  void
*** 1.1	1991/08/12 10:41:10
--- nuxdsp.c	1991/08/12 10:50:24
***************
*** 381,386 ****
--- 381,388 ----
    short a, r, c, sq, i;
    char s[80];
  
+   flag.regularstart = false;
+   Book = NULL;
    ClrScreen ();
    UpdateDisplay (0, 0, 1, 0);
    gotoXY (TAB, 3);
***************
*** 1137,1142 ****
--- 1139,1146 ----
  	}
      }
    GameCnt = 0;
+   flag.regularstart = false;
+   Book = NULL;
    fgets (fname, 256, fd);
    fgets (fname, 256, fd);
    fgets (fname, 256, fd);
***************
*** 1206,1211 ****
--- 1210,1217 ----
    if ((fd = fopen (fname, "r")) != NULL)
      {
        NewGame ();
+       flag.regularstart = false;
+       Book = NULL;
        fgets (fname, 256, fd);
        fname[6] = '\0';
        if (strcmp (fname, "xboard"))
***************
*** 1423,1428 ****
--- 1429,1436 ----
    ShowSidetoMove ();
    UpdateDisplay (0, 0, 1, 0);
    InitializeStats ();
+   if (flag.regularstart)
+     Book = BKBook;
  }
  
  void
*** 1.1	1991/08/12 10:41:10
--- uxdsp.c	1991/08/12 10:50:24
***************
*** 344,349 ****
--- 344,351 ----
    short a, r, c, sq, i;
    char s[80];
  
+   flag.regularstart = false;
+   Book = NULL;
    ClrScreen ();
    UpdateDisplay (0, 0, 1, 0);
    gotoXY (TAB, 3);
***************
*** 978,983 ****
--- 980,987 ----
  	}
      }
    GameCnt = 0;
+   flag.regularstart = false;
+   Book = NULL;
    fgets (fname, 256, fd);
    fgets (fname, 256, fd);
    fgets (fname, 256, fd);
***************
*** 1049,1054 ****
--- 1053,1060 ----
    if ((fd = fopen (fname, "r")) != NULL)
      {
        NewGame ();
+       flag.regularstart = false;
+       Book = NULL;
        fgets (fname, 256, fd);
        fname[6] = '\0';
        if (strcmp (fname, "xboard"))
***************
*** 1266,1271 ****
--- 1272,1279 ----
    ShowSidetoMove();
    UpdateDisplay (0, 0, 1, 0);
    InitializeStats ();
+   if (flag.regularstart)
+     Book = BKBook;
  }
  
  void
SHAR_EOF
fi # end of overwriting check
#	End of shell archive
exit 0

exit 0 # Just in case...
-- 
Kent Landfield                   INTERNET: kent@sparky.IMD.Sterling.COM
Sterling Software, IMD           UUCP:     uunet!sparky!kent
Phone:    (402) 291-8300         FAX:      (402) 291-4362
Please send comp.sources.misc-related mail to kent@uunet.uu.net.


