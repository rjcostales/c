From pa.dec.com!decwrl!uunet!sparky!kent Sun Aug 11 15:26:22 PDT 1991
Article: 2558 of comp.sources.misc
Newsgroups: comp.sources.misc
Path: pa.dec.com!decwrl!uunet!sparky!kent
From: Mike McGann <mwm@hasler.ascom.ch>
Subject:  v21i048:  gnuchess - gnuchess version 3.1+, Patch02
Message-ID: <1991Aug2.005505.896@sparky.IMD.Sterling.COM>
X-Md4-Signature: 63624b0ed67fbd6ae31d04652b2bcc71
Sender: kent@sparky.IMD.Sterling.COM (Kent Landfield)
Organization: Sterling Software, IMD
Date: Fri, 2 Aug 1991 00:55:05 GMT
Approved: kent@sparky.imd.sterling.com
Lines: 612

Submitted-by: Mike McGann <mwm@hasler.ascom.ch>
Posting-number: Volume 21, Issue 48
Archive-name: gnuchess/patch02
Patch-To: gnuchess: Volume 19, Issue 73-79
Environment: UNIX, DOS

Here are patches to gnuchess3.1+ that allow it to be used
with chesstool.  There is also a patch to ChessFont that
makes the halos fit correctly on the white pawns as pointed
out by A. N. Walker, the author of ChessFont.  Please note 
that ChessFont is neither copylefted nor public domain. The
file README.font is also included in this patch. In addition,
I changed the makefile to name the versions for X and sunview 
different names rather than have them all called gnuchessr.  
To make an xboard version of gnuchessr type 'make xboard'.  
To make a chesstool version type 'make chesstool'

To apply these patches, cd into the gnuchess source directory
and unshar this file.  You will need to patch the sources by
typing:

patch < ChessFont.patch
patch < Makefile.patch
patch < nondsp.patch
rm *.orig *.patch

Mike Mcgann
mwm@hslrswi.hasler.ascom.ch
----
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	ChessFont.patch
#	Makefile.patch
#	nondsp.patch
#	README.font
# This archive created: Mon Jul 29 07:44:51 1991
export PATH; PATH=/bin:$PATH
if test -f 'ChessFont.patch'
then
	echo shar: will not over-write existing file "'ChessFont.patch'"
else
cat << \SHAR_EOF > 'ChessFont.patch'
*** /tmp/DIST/ChessFont	Mon Jul 29 07:35:40 1991
--- ChessFont	Mon Jul 29 07:31:09 1991
***************
*** 314,320 ****
  	% behaviour.  Also, they are the only symbols for which this is
  	% easy!
  
! 	/WP { setpce Setfont setW 0 0 moveto (f) tofig show setB (P) Tofig
  		-500 -300 rmoveto show } bind def
  	/BP { setpce Setfont setW 0 0 moveto (f) tofig show setB (r) tofig
  		show } bind def
--- 314,320 ----
  	% behaviour.  Also, they are the only symbols for which this is
  	% easy!
  
! 	/WP { setpce Setfont setW 0 0 moveto (f) tofig show setB (P) tofig
  		-500 -300 rmoveto show } bind def
  	/BP { setpce Setfont setW 0 0 moveto (f) tofig show setB (r) tofig
  		show } bind def
SHAR_EOF
fi # end of overwriting check
if test -f 'Makefile.patch'
then
	echo shar: will not over-write existing file "'Makefile.patch'"
else
cat << \SHAR_EOF > 'Makefile.patch'
*** /tmp/DIST/Makefile	Mon Jul 29 07:35:41 1991
--- Makefile	Mon Jul 29 07:27:05 1991
***************
*** 22,28 ****
  #
  # gnuchess  will be the curses-based chess.
  # gnuchessn will be the fancy-display-curses-based chess.
! # gnuchessr will be the xchess/chesstool based chess.
  #		(/usr/games/chesstool gnuchessr)
  #    for use with SUN's chesstool and X-window's xchess.
  #    To use with latter, add -DCHESSTOOL to the nondsp.o
--- 22,30 ----
  #
  # gnuchess  will be the curses-based chess.
  # gnuchessn will be the fancy-display-curses-based chess.
! # gnuchessr will be the unfancy tty based chess.
! # gnuchessc will be the chesstool based chess.
! # gnuchessx will be the xchess based chess.
  #		(/usr/games/chesstool gnuchessr)
  #    for use with SUN's chesstool and X-window's xchess.
  #    To use with latter, add -DCHESSTOOL to the nondsp.o
***************
*** 47,62 ****
  #CFLAGS= -O -Dinline=""		# for Aviion gcc-1.35
  CFLAGS=	-O -finline-functions -fstrength-reduce
  
! all : gnuchess gnuchessr gnuchessn postprint gnuan
  
  gnuchess: gnuchess.o uxdsp.o
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchess gnuchess.o uxdsp.o $(LCURSES)
  
! gnuan: gnuchess.o gnuan.o
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuan gnuchess.o gnuan.o
  
! gnuchessr: gnuchess.o nondsp.o
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuchessr gnuchess.o nondsp.o
  
  gnuchessn: gnuchess.o nuxdsp.o
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchessn gnuchess.o nuxdsp.o $(LCURSES)
--- 49,73 ----
  #CFLAGS= -O -Dinline=""		# for Aviion gcc-1.35
  CFLAGS=	-O -finline-functions -fstrength-reduce
  
! all : gnuchess gnuchessr gnuchessn xboard chesstool postprint gnuan
  
  gnuchess: gnuchess.o uxdsp.o
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchess gnuchess.o uxdsp.o $(LCURSES)
  
! gnuan: gnuchess.o gnuan.o nondsp.c
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuan gnuchess.o gnuan.o
  
! chesstool: gnuchess.o nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -c nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DCHESSTOOL -o gnuchessc gnuchess.o nondsp.o
! 
! xboard: gnuchess.o nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DXBOARD -c nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -DXBOARD -o gnuchessx gnuchess.o nondsp.o
! 
! gnuchessr: gnuchess.o nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -c nondsp.c
! 	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchessr gnuchess.o nondsp.o
  
  gnuchessn: gnuchess.o nuxdsp.o
  	$(CC) $(CFLAGS) $(HASH) $(BOOK) -o gnuchessn gnuchess.o nuxdsp.o $(LCURSES)
***************
*** 106,109 ****
  	cp gnuchess.book $(LIBDIR)/gnuchess.book
  
  clean:
! 	-rm gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan *.o
--- 117,120 ----
  	cp gnuchess.book $(LIBDIR)/gnuchess.book
  
  clean:
! 	-rm gnuchessx gnuchessc gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan *.o
SHAR_EOF
fi # end of overwriting check
if test -f 'nondsp.patch'
then
	echo shar: will not over-write existing file "'nondsp.patch'"
else
cat << \SHAR_EOF > 'nondsp.patch'
*** /tmp/DIST/nondsp.c	Mon Jul 29 07:36:12 1991
--- nondsp.c	Wed Jul 24 10:36:20 1991
***************
*** 53,59 ****
  short int debuglevel = 0;
  FILE *debugfd;
  #endif /*DEBUG*/
! #ifdef CHESSTOOL
  short int chesstool = 1;
  #else
  short int chesstool = 0;
--- 53,59 ----
  short int debuglevel = 0;
  FILE *debugfd;
  #endif /*DEBUG*/
! #if defined CHESSTOOL || defined XBOARD
  short int chesstool = 1;
  #else
  short int chesstool = 0;
***************
*** 70,76 ****
  Initialize (void)
  {
    mycnt1 = mycnt2 = 0;
! #ifdef CHESSTOOL
    setlinebuf (stdout);
    /* setvbuf(stdout,NULL,_IOLBF,BUFSIZ); */
    printf ("Chess\n");
--- 70,76 ----
  Initialize (void)
  {
    mycnt1 = mycnt2 = 0;
! #if defined CHESSTOOL || defined XBOARD
    setlinebuf (stdout);
    /* setvbuf(stdout,NULL,_IOLBF,BUFSIZ); */
    printf ("Chess\n");
***************
*** 220,226 ****
--- 220,230 ----
        if (SqAtakd (PieceList[opponent][0], computer))
  	{
  	  UnmakeMove (opponent, &xnode, &tempb, &tempc, &tempsf, &tempst);
+ #if defined CHESSTOOL
+ 	  printz ("Illegal move\n");
+ #else
  	  printz ("Illegal move..(you are in check)\n");
+ #endif /*CHESSTOOL*/
  	  return (false);
  	}
        else
***************
*** 246,254 ****
  	  return (true);
  	}
      }
! #ifdef CHESSTOOL
    printz ("Illegal move (no matching move generated)");
    printz ("%s\n", s);
  #ifdef DEBUG
    if (true)
      {
--- 250,261 ----
  	  return (true);
  	}
      }
! #if defined CHESSTOOL 
!   printz ("Illegal move\n");
! #else
    printz ("Illegal move (no matching move generated)");
    printz ("%s\n", s);
+ #endif /*CHESSTOOL*/
  #ifdef DEBUG
    if (true)
      {
***************
*** 280,286 ****
        fprintf (debugfd, "\n");
      }
  #endif /* DEBUG*/
! #else
    if (cnt > 1)
      ShowMessage ("Ambiguous Move!");
  #endif /*CHESSTOOL*/
--- 287,293 ----
        fprintf (debugfd, "\n");
      }
  #endif /* DEBUG*/
! #if !defined CHESSTOOL && !defined XBOARD
    if (cnt > 1)
      ShowMessage ("Ambiguous Move!");
  #endif /*CHESSTOOL*/
***************
*** 477,483 ****
  ShowResults (short int score, short unsigned int *bstline, char ch)
  {
    register int i;
! #ifndef CHESSTOOL
    if (flag.post)
      {
        fprintf (stderr, "%2d%c %6d %4ld %8ld  ", Sdepth, ch, score, et, NodeCnt);
--- 484,490 ----
  ShowResults (short int score, short unsigned int *bstline, char ch)
  {
    register int i;
! #if !defined CHESSTOOL && !defined XBOARD
    if (flag.post)
      {
        fprintf (stderr, "%2d%c %6d %4ld %8ld  ", Sdepth, ch, score, et, NodeCnt);
***************
*** 499,505 ****
  #ifndef MSDOS
    signal (SIGQUIT, TerminateSearch);
  #endif /* MSDOS */
! #ifndef CHESSTOOL
    if (flag.post)
      {
        fprintf (stderr, "\nMove# %d    Target= %ld    Clock: %ld\n",
--- 506,512 ----
  #ifndef MSDOS
    signal (SIGQUIT, TerminateSearch);
  #endif /* MSDOS */
! #if !defined CHESSTOOL && !defined XBOARD
    if (flag.post)
      {
        fprintf (stderr, "\nMove# %d    Target= %ld    Clock: %ld\n",
***************
*** 531,537 ****
        printz ("%s\n", ColorStr[computer]);
        ExitChess ();
      }
! #ifndef CHESSTOOL
    if (flag.post)
      {
        fprintf (stderr, "Nodes= %ld  Eval= %ld  Rate= %ld  ",
--- 538,544 ----
        printz ("%s\n", ColorStr[computer]);
        ExitChess ();
      }
! #if !defined CHESSTOOL && !defined XBOARD
    if (flag.post)
      {
        fprintf (stderr, "Nodes= %ld  Eval= %ld  Rate= %ld  ",
***************
*** 545,553 ****
  #ifdef DEBUG
    fprintf (debugfd, "My move is: %s\n", mvstr[0]);
  #endif /* DEBUG */
    if (flag.beep)
      printz ("%c", 7);
! 
    if (root->flags & draw)
      fprintf (stderr, "Drawn game!\n");
    else if (root->score == -9999)
--- 552,561 ----
  #ifdef DEBUG
    fprintf (debugfd, "My move is: %s\n", mvstr[0]);
  #endif /* DEBUG */
+ #if !defined CHESSTOOL
    if (flag.beep)
      printz ("%c", 7);
! #endif /*CHESSTOOL*/
    if (root->flags & draw)
      fprintf (stderr, "Drawn game!\n");
    else if (root->score == -9999)
***************
*** 629,635 ****
  void
  ClrScreen (void)
  {
! #ifndef CHESSTOOL
    printz ("\n");
  #endif
  }
--- 637,643 ----
  void
  ClrScreen (void)
  {
! #if !defined CHESSTOOL && !defined XBOARD
    printz ("\n");
  #endif
  }
***************
*** 1065,1071 ****
  void
  PromptForMove (void)
  {
! #ifndef CHESSTOOL
    printz ("\nYour move is? ");
  #endif /* CHESSTOOL */
  }
--- 1073,1079 ----
  void
  PromptForMove (void)
  {
! #if !defined CHESSTOOL && !defined XBOARD
    printz ("\nYour move is? ");
  #endif /* CHESSTOOL */
  }
***************
*** 1230,1241 ****
        player = opponent;
        if (strcmp (s, "bd") == 0)
  	{
! #ifdef CHESSTOOL
  	  chesstool = 0;
  #endif /*CHESSTOOL*/
  	  ClrScreen ();
  	  UpdateDisplay (0, 0, 1, 0);
! #ifdef CHESSTOOL
  	  chesstool = 1;
  #endif /*CHESSTOOL*/
  	}
--- 1238,1249 ----
        player = opponent;
        if (strcmp (s, "bd") == 0)
  	{
! #if defined CHESSTOOL || defined XBOARD
  	  chesstool = 0;
  #endif /*CHESSTOOL*/
  	  ClrScreen ();
  	  UpdateDisplay (0, 0, 1, 0);
! #if defined CHESSTOOL || defined XBOARD
  	  chesstool = 1;
  #endif /*CHESSTOOL*/
  	}
***************
*** 1367,1373 ****
        computer = opponent;
        opponent = otherside[computer];
      }
! #ifdef CHESSTOOL
    printf ("%d. %s", ++mycnt2, s);
    if (flag.post)
      {
--- 1375,1381 ----
        computer = opponent;
        opponent = otherside[computer];
      }
! #if defined CHESSTOOL || defined XBOARD
    printf ("%d. %s", ++mycnt2, s);
    if (flag.post)
      {
SHAR_EOF
fi # end of overwriting check
if test -f 'README.font'
then
	echo shar: will not over-write existing file "'README.font'"
else
cat << \SHAR_EOF > 'README.font'
PostScript Chess Font -- "README" file.
========== ===== ==== == ======== =====

	Copyright (c) 1991 A. N. Walker.  All rights reserved.

Restrictions on Use:
------------ -- ----
	You must keep the copyright notice on this file and on the
accompanying "Font" file.  If you change anything, you must clearly
mark your changes.  Otherwise, you may use these files as you please
for private, educational or research purposes.  You may also use them
freely for commercial purposes as long as you do not make any changes
to the shapes of the pieces without my approval.

	I do not, and am in no position to, make any claim as to
suitability of these files for any specific purpose.  They work for
me, and if they work for you too I shall be pleased.  If they do not
work for you, well, you have what you paid for.

	If you are pleased with the results, please let me [and your
readers, if any!] know.  If you manage to make money out of them,
please let me know how!  I'd quite like to see [real or PostScript]
copies of what you manage to do, if you have the necessary time,
inclination and resources.

	If you don't like the results, please let me know why.  Indeed,
if you have any comments, please e- or snail- mail them to me.

What you have to do:
---- --- ---- -- ---
	You should have three files, called "Font", "Demo" and "Table".
If you have a way of viewing PostScript, shovel "Font" and "Demo" or
"Font" and "Table" at it;  for example, I use the commands

		lpr -Plwriter Font Demo
		lpr -Plwriter Font Table

to see the results on "my" LaserWriter.  If you have no way of viewing
PostScript, then I'm sorry, but I can't help you.  What you should see
is an assorted collection of boards and figurines in various sizes and
rotations ("Demo") or a neat table showing all the symbols in the font
("Table").  If anything else happens, you will have to consult someone
who knows what they're doing -- *not* me!  I can promise you that the
files as shipped print nicely on a bog-standard Apple LW+.  They take
several minutes each to print on our LW+;  this is largely because they
make almost pessimal use of the font caching mechanism -- lots of big
characters are printed once each in different sizes and orientations.
Conventional pages with lots of figurines or ordinary text and only a
few diagrams print acceptably quickly (especially, of course, if you
have a faster or more recent LW).

	If you are happy with the demos, you can then install the "Font"
file as a font in your system.

	****************************************
	* I cannot help you with this process! *
	****************************************

I can't even do it for our own computer, which has a much-hacked (from
its PDP-11 days) version of Troff;  I leave it to our guru.  Neither
he nor I know what magic you have to utter for an unhacked Troff, or
for TEX, or for Macs or PCs or whatever weird and wonderful software
or hardware you possess.  When you install the font, you may also find
it useful to grab some of the PostScript code from "Demo", especially
if you want to draw (for example) labelled diagrams.

What there is in the Font:
---- ----- -- -- --- -----
	There are really two fonts wrapped up into one.  The more
conventional sub-font is the so-called "text mode", and is what you
get when you first select the font.  This mode itself has two major
components.  The upper case letters are the figurines, for use in
text.  For example, "Q" draws a queen figurine.  Lower case letters
and other symbols are (most of) the Informant symbols (omitting only
symbols like "?" and "ch" that you can reasonably expect to find in
boring old Times Roman, but including "+" and "-").  I've been as
mnemonic as I could, but there are just too many symbols.

	The other sub-font is "diagram mode".  In this, upper case
letters draw white pieces, and lower case letters draw black pieces.
For example, "Knk" draws a white king adjacent to a black knight
and a black king.  The pieces include a selection of fairy pieces
and other related symbols -- everything I've seen or had reported
to me on chess diagrams in the last few years.  The other symbols
in this sub-font consist of board-drawing components and motions
to facilitate the construction of diagrams.  You switch between
text and diagram modes using the prime symbol, "'".  For example,
the famous Reti study can be diagrammed by the PostScript:

		('#[7K;8;k1P;7p;8;8;8;8]') show

where "#" draws the board, and the stuff between "[...]" is the
conventional Forsythe notation for the position.  Obviously, for
practical use, you will need a chess pre-processor (which I have
*not* written!).

	Most of the capabilities of the font are illustrated on
the demo page, which also includes some possibly-useful PostScript
procedures for various of the effects.

	Warning:  the dual-mode font treads on very thin ice in
some places!  In particular, the caching mechanisms of PostScript
are very easy to fool with a dynamic font of this type.  For example,
finding the width of a string is fraught with danger;  do it only
with strings that include matched pairs of primes.

The font design:
--- ---- -------
	There are surprisingly many different chess fonts in use in
printed books.  I have tried to copy the simplest -- for example,
the rooks have no brickwork, and the kings are quite plain.  Note
that the pieces do not scale well.  Large pieces (inches high) for
posters, etc., will have to be specially designed (and are usually
based on "real" Staunton pieces).  Tiny pieces suffer from the lack
of resolution on 300 dpi (or coarser) printers.  On a 300 dpi printer,
7-point is really too small, anything less is hopeless (see the demo).
I usually use 15-point, which is comparable with most books.

	The hardest piece to get right is the knight.  The book designs
are hopeless at 300 dpi resolution, as there are too many fine lines
around the mouth and chin.  Any attempts to copy them just look like a
caricature.  So I've made it a bit chunkier.  Most readers don't notice.

	Note that most of the pieces (as opposed to the figurines)
cannot be cached.  This is because they include both write-white and
write-black components (partly, but not entirely, because they have
to work on black squares);  this makes drawing a whole page of black
kings (or whatever) rather slooow.  Fortunately, you don't often need
such a thing.  The figurines *are* cached, so are the Informant symbols,
and so are the commonest pieces (the black squares, and the pawns of
both colours).

Foreign usage:
------- ------
	Foreign users may want to re-assign the letters used for the
various pieces.  This can easily be done in the Font file.  Lines
such as

	dup 8#113 /WK put		% 'K'

(not too far down the file) signify that ASCII character 113 (octal), or
"K", is to draw the White King.  If you want some other character to draw
the WK, alter the 113 to match.  You will have to change the BK and Kfig
by the same amount, and you will also have to reassign whatever symbol
your chosen character already draws, if any.  Another minor problem is
that some of the fairy pieces are defined explicitly in terms of the
existing pieces -- eg, if you decide to use "F" to draw White queens,
then the procedure for Grasshoppers (look for "WG" in Font) must be
changed to draw upside-down "F" instead of upside-down "Q".  I hope the
necessary edits are obvious even to non-PostScript users.  I suggest that
after any change you try the Table and Demo files again.

Unusual chess pieces:
------- ----- -------
	I've included a fair number of pieces that may not be familiar to
all chess players.  These include:
	F for fou, French version of bishop.  There are several designs
	    of fou in print, I have selected the easiest to implement.  If
	    you want one of the others, you'll have to write it yourself.
	D,X for draughts pieces.  Note that these are not cached (except
	    as figurines);  if you are writing a book on draughts with
	    lots of diagrams, you might find it worthwhile to re-write
	    them in a cachable way.  This is easier if you want to use
	    them on the white squares (you don't need the "halo" effect),
	    but the books I have seen are about equally split on this.
	C,I,T for chameleon, imitator, rose.  Various fairy pieces.
	E,G,L,M,O,S,U,V,Z for various rotated standard pieces, used in
	    fairy chess.  Note that the "Demo" file includes a more
	    general way to rotate a piece.  I have used S for nightrider,
	    oppositely to the problemists convention which uses S for
	    knight and N for nightrider;  there is no way that the average
	    player is going to change his habits!  If you are a problemist,
	    feel free to interchange S and N (and then M and Z).
	.,@,|,_ for various other marks useful in annotating diagrams.
	    See the "Demo" file for examples of their use.
	A,H,J,W,Y are unused.  Feel free to use them to add new pieces.

Go pieces:
-- -------
	Sorry, despite several requests, I haven't put these in.  I
can't save the whole world in one easy lesson.  The pieces themselves
and the board are easy in PostScript;  the annotations and the necessary
pre-processor are another kettle of fish.  The Go stones could also be
used for Reversi (Othello).

Bridge symbols:
------ --------
	No-one has actually asked for these, but just to forestall you,
note that they are already provided in many places -- symbol fonts,
dingbats fonts, Hershey fonts, ....

Final comments:
----- ---------
	Suggestions for improvements, especially in the PostScript,
will be welcomed.  Especially if they improve portability (which I
can't check locally!).  Especially if you've tried them yourself,
and can vouch that they work.  Suggestions for extra symbols (other
than Go or Bridge) also welcomed, especially if accompanied by
PostScript or other descriptions of their shape.

-- 
Andy Walker, Maths Dept., Nott'm Univ., UK.
anw@maths.nott.ac.uk
SHAR_EOF
fi # end of overwriting check
#	End of shell archive
exit 0

exit 0 # Just in case...


